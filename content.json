{"meta":{"title":"vetch的小小世界","subtitle":null,"description":"陌上花开，可缓缓归矣","author":"Weiquan Fan","url":"http://weiquanfan.xyz","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-05-03T16:06:52.229Z","updated":"2019-08-02T02:17:12.000Z","comments":false,"path":"/404.html","permalink":"http://weiquanfan.xyz//404.html","excerpt":"","text":""},{"title":"About","date":"2020-05-03T16:34:43.608Z","updated":"2020-05-03T16:34:43.608Z","comments":false,"path":"about/index.html","permalink":"http://weiquanfan.xyz/about/index.html","excerpt":"","text":"我是谁我在哪我要去哪里"},{"title":"Categories","date":"2020-05-03T16:35:38.847Z","updated":"2020-05-03T16:35:38.847Z","comments":false,"path":"categories/index.html","permalink":"http://weiquanfan.xyz/categories/index.html","excerpt":"","text":""},{"title":"Books","date":"2020-05-03T16:35:07.806Z","updated":"2020-05-03T16:35:07.806Z","comments":false,"path":"books/index.html","permalink":"http://weiquanfan.xyz/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-05-03T16:06:52.302Z","updated":"2019-08-02T02:17:12.000Z","comments":false,"path":"repository/index.html","permalink":"http://weiquanfan.xyz/repository/index.html","excerpt":"","text":""},{"title":"Links","date":"2020-05-03T16:35:31.293Z","updated":"2020-05-03T16:35:31.293Z","comments":false,"path":"links/index.html","permalink":"http://weiquanfan.xyz/links/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-05-03T16:35:25.551Z","updated":"2020-05-03T16:35:25.551Z","comments":false,"path":"tags/index.html","permalink":"http://weiquanfan.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"使用QT designer、python搭建界面程序","slug":"QT","date":"2020-06-10T06:49:28.000Z","updated":"2020-06-10T07:00:16.954Z","comments":true,"path":"2020/06/10/QT/","link":"","permalink":"http://weiquanfan.xyz/2020/06/10/QT/","excerpt":"","text":"前言PyQt 是Python语言的GUI编程解决方案之一，是类似于 Tkinter 的一个高级库。 为了更好的辅助PyQt界面的搭建，可以通过Qt Designer完成GUI界面设计。 使用Qt Designer可以通过拖拽、点击完成GUI界面设计，并且设计完成后生成的.ui程序可以通过 pyuic5 命令直接转换成.py文件以供python程序调用。 搭建完界面并写好逻辑后，还可通过 pyinstaller 将.py文件封装成.exe文件，以供没有python解释器的用户使用。 本文以搭建标注工具界面程序为例。 预安装的软件与库 Qt Designer: pip install —pre pyqt5-tools~=5.11（位于\\Python36\\Lib\\site-packages\\pyqt5_tools\\designer.exe，也可通过这里下载） PyQt5: pip install PyQt5 pip install pyinstaller Qt Designer 的界面设计 Qt Designer 的界面主要分为四大区：项目区、控件区、编辑区、属性区。 具体而言，就是在【控件区】里点击添加需要的控件，这些控件的效果会在【编辑区】里实时显示，并在【属性区】这些控件的属性，【项目区】用于显示控件间的层级关系。 在新建一个窗口后，一般需要通过 Container 确定外部轮廓，可选用常见的 Frame 控件，再在 Frame 里边选用 Layouts 来规范后续控件的排列样式，常用水平或垂直排列，最后再选用具体部件往里边填充。 常用的控件有各种Button（按钮）、Label（静态显示文本框）、Text Edit（输入输出文本框）、listWidget（列表显示框）、Check Box（选中框）、各种Slider（滑动条）等。 每一个组件都有可设置的属性，最重要的通用属性有 objectName （用于在后续逻辑编写时指明时哪个控件），text （用于在GUI里在控件上显示）， geometry （用于设置控件位置和尺寸，但控件位于Layer中时就不可设置了）。 设计好界面之后保存可以生成my_win.ui文件，它可以直接在python代码里被加载使用，但为了在代码里进一步调用修改等，更好的方法是将.ui文件转换成相应的.py文件。这需要借助 \\Python36\\Scripts\\pyuic5.exe工具。 pyuic5 - o my_win.py my_win.ui Qt 逻辑编写很多控件都可以通过点击（或其他操作）触发事件，事件响应可自由编写，通过 connect 函数绑定。 #!/usr/bin/env python # -*- coding: utf-8 -*- import sys, os from PyQt5.QtWidgets import QApplication, QMainWindow, QMessageBox from my_win import Ui_MainWindow import csv path_metadata = &quot;./metadata.csv&quot; # 保存生成数据的路径 class mainWin(QMainWindow, Ui_MainWindow): def __init__(self, parent=None): super(mainWin, self).__init__(parent) self.setupUi(self) self.radioButton.clicked.connect(self.showPos) # 绑定事件响应 self.radioButton_2.clicked.connect(self.showNeu) self.radioButton_3.clicked.connect(self.showNeg) self.btn_save.clicked.connect(self.save_data) self.btn_del.clicked.connect(self.del_last_data) ## 点击 radioButton 时，向 listWidget 添加项以供后续选择 def showPos(self): self.label_val = &quot;正向情绪&quot; self.listWidget.clear() self.listWidget.addItem(&quot;高兴&quot;) self.listWidget.addItem(&quot;兴奋&quot;) self.listWidget.addItem(&quot;自豪&quot;) self.listWidget.addItem(&quot;满足&quot;) self.listWidget.addItem(&quot;感激&quot;) self.listWidget.addItem(&quot;自信&quot;) self.listWidget.addItem(&quot;轻松&quot;) self.listWidget.addItem(&quot;羡慕&quot;) def showNeg(self): self.label_val = &quot;负向情绪&quot; self.listWidget.clear() self.listWidget.addItem(&quot;生气&quot;) self.listWidget.addItem(&quot;伤心&quot;) self.listWidget.addItem(&quot;害怕&quot;) self.listWidget.addItem(&quot;烦恼&quot;) self.listWidget.addItem(&quot;孤独&quot;) self.listWidget.addItem(&quot;羞愧&quot;) self.listWidget.addItem(&quot;恶心&quot;) self.listWidget.addItem(&quot;失望&quot;) self.listWidget.addItem(&quot;郁闷&quot;) self.listWidget.addItem(&quot;不安&quot;) self.listWidget.addItem(&quot;紧张&quot;) self.listWidget.addItem(&quot;无奈&quot;) self.listWidget.addItem(&quot;纠结&quot;) def showNeu(self): self.label_val = &quot;中性情绪&quot; self.listWidget.clear() self.listWidget.addItem(&quot;共情&quot;) self.listWidget.addItem(&quot;平静&quot;) ## 点击保存按键时，将界面上的数据保存成一行生成csv文件 def save_data(self): if not os.path.exists(path_metadata): with open(path_metadata,&quot;a&quot;,newline=&#39;&#39;,encoding=&#39;utf_8_sig&#39;) as csvfile: writer = csv.writer(csvfile, delimiter=&#39;,&#39;) writer.writerow([&#39;样本名称&#39;, &#39;起始时间&#39;, &#39;结束时间&#39;, &#39;情绪（粗粒度）&#39;, &#39;情绪（细粒度）&#39;, &#39;是否基于音频&#39;, &#39;是否基于视频&#39;, &#39;是否基于文本&#39;, &#39;是否难以标注&#39;, &#39;对话状态&#39;]) try: self.label_emotion = self.listWidget.selectedItems()[0].text() except IndexError: QMessageBox.information(self,&#39;提示&#39;,&#39;请选择具体情感后再重新保存&#39;, QMessageBox.Yes) return 0 self.label_emotion_audio_based = self.checkBox_3.isChecked() self.label_emotion_video_based = self.checkBox_2.isChecked() self.label_emotion_text_based = self.checkBox.isChecked() self.label_emotion_hard = self.checkBox_4.isChecked() try: self.label_da = self.listWidget_2.selectedItems()[0].text() except IndexError: QMessageBox.information(self,&#39;提示&#39;,&#39;请选择对话状态后再重新保存&#39;, QMessageBox.Yes) return 0 if self.lineEdit.text() == &#39;&#39;: QMessageBox.information(self,&#39;提示&#39;,&#39;请输入样本名字&#39;, QMessageBox.Yes) return 0 else: self.name_sample = self.lineEdit.text() try: self.start_time = &quot;{}:{}:{}&quot;.format(int(self.lineEdit_2.text()), int(self.lineEdit_3.text()), int(self.lineEdit_4.text())) self.end_time = &quot;{}:{}:{}&quot;.format(int(self.lineEdit_5.text()), int(self.lineEdit_6.text()), int(self.lineEdit_7.text())) except: QMessageBox.information(self,&#39;提示&#39;,&#39;时间应输入整数&#39;, QMessageBox.Yes) return 0 onelist = [self.name_sample, self.start_time, self.end_time, self.label_val, self.label_emotion, self.label_emotion_audio_based, self.label_emotion_video_based, self.label_emotion_text_based, self.label_emotion_hard, self.label_da] with open(path_metadata,&quot;a&quot;,newline=&#39;&#39;,encoding=&#39;utf_8_sig&#39;) as csvfile: writer = csv.writer(csvfile, delimiter=&#39;,&#39;) writer.writerow(onelist) QMessageBox.about(self,&#39;提示&#39;,&#39;保存成功&#39;) ## 点击删除按键时，从数据中删除掉最后一行 def del_last_data(self): try: with open(path_metadata,&quot;r&quot;,newline=&#39;&#39;,encoding=&#39;utf_8_sig&#39;) as csvfile: data = csvfile.readlines() del data[-1] with open(path_metadata,&quot;w&quot;,newline=&#39;&#39;,encoding=&#39;utf_8_sig&#39;) as csvfile: writer = csv.writer(csvfile, delimiter=&#39;,&#39;) for row in data: writer.writerow(row.strip().split(&#39;,&#39;)) # writer.writerows(data) QMessageBox.about(self,&#39;提示&#39;,&#39;删除成功&#39;) except: QMessageBox.information(self,&#39;提示&#39;,&#39;尚未保存任何数据&#39;, QMessageBox.Yes) if __name__ == &#39;__main__&#39;: ## 固定套路 app = QApplication(sys.argv) main_win = mainWin() main_win.show() sys.exit(app.exec_()) 封装成可执行文件对于编写好的.py文件，若是需要更好的给没有python编辑器的人使用，则需要封装成.exe文件，这可以通过 pyinstaller 命令来完成。 pyinstaller -F biaozhu.py pyinstaller 有两种常见的模式：-F: 將程式打包成单一的执行文件(适合比较简单的代码)-D: 打包多個文件，exe及依赖的东西会一起放置在dist資料夾里(适合框架形式的程式) 在打包过程中，包含如下步骤 在路径下生成了biaozhu.spec: 包含打包时相关的设定 建立build 文件夹，放置了log记录和相关文件 建立dist 文件夹，放置了可执行文件，若是 —F 模式，则里边仅有一个.exe文件 另外，若是打包失败，可以通过改写.spec文件，再通过 pyinstaller -D XXX.spec 重新打包。 如果是库的 import 问题，可以通过 hiddenimport 里放置库名来hidden掉该错误。 总结以前只知道 Tkinter 可以来实现 python 的界面设计，但感觉并不那么友好。 而这次学习到的 PyQt 以及相应的 Qt designer则很好的解决了这一问题，可以通过拉拽进行布局，就像c++的SDL一样。完成界面设计后的逻辑编写才是更让人头疼的问题，容易产生各种bug，只能慢慢调。 最后完成程序之后还可以转成.exe文件，从而可以直接给别人使用，这个是意料之外的惊喜。","categories":[{"name":"界面","slug":"界面","permalink":"http://weiquanfan.xyz/categories/界面/"}],"tags":[{"name":"界面","slug":"界面","permalink":"http://weiquanfan.xyz/tags/界面/"}]},{"title":"深度学习主流框架的代码实例","slug":"DL-Framework","date":"2020-05-27T14:57:23.000Z","updated":"2020-05-27T15:29:06.309Z","comments":true,"path":"2020/05/27/DL-Framework/","link":"","permalink":"http://weiquanfan.xyz/2020/05/27/DL-Framework/","excerpt":"","text":"前言深度学习框架从一开始的 Theano、TensorFlow，到后来封装程度更高的Pytorch、Keras等，层出不穷。此文通过一个简单的分类任务，综合进这些框架的代码。代码来源于莫烦python。 Theanofrom __future__ import print_function import numpy as np import theano import theano.tensor as T def compute_accuracy(y_target, y_predict): correct_prediction = np.equal(y_predict, y_target) accuracy = np.sum(correct_prediction)/len(correct_prediction) return accuracy rng = np.random N = 400 # training sample size feats = 784 # number of input variables # generate a dataset: D = (input_values, target_class) D = (rng.randn(N, feats), rng.randint(size=N, low=0, high=2)) # Declare Theano symbolic variables x = T.dmatrix(&quot;x&quot;) y = T.dvector(&quot;y&quot;) # initialize the weights and biases W = theano.shared(rng.randn(feats), name=&quot;w&quot;) b = theano.shared(0., name=&quot;b&quot;) # Construct Theano expression graph p_1 = T.nnet.sigmoid(T.dot(x, W) + b) # Logistic Probability that target = 1 (activation function) prediction = p_1 &gt; 0.5 # The prediction thresholded xent = -y * T.log(p_1) - (1-y) * T.log(1-p_1) # Cross-entropy loss function # or # xent = T.nnet.binary_crossentropy(p_1, y) # this is provided by theano cost = xent.mean() + 0.01 * (W ** 2).sum()# The cost to minimize (l2 regularization) gW, gb = T.grad(cost, [W, b]) # Compute the gradient of the cost # Compile learning_rate = 0.1 train = theano.function( inputs=[x, y], outputs=[prediction, xent.mean()], updates=((W, W - learning_rate * gW), (b, b - learning_rate * gb))) predict = theano.function(inputs=[x], outputs=prediction) # Training for i in range(500): pred, err = train(D[0], D[1]) if i % 50 == 0: print(&#39;cost:&#39;, err) print(&quot;accuracy:&quot;, compute_accuracy(D[1], predict(D[0]))) print(&quot;target values for D:&quot;) print(D[1]) print(&quot;prediction on D:&quot;) print(predict(D[0]) 先搭建计算图，再通过theano.function绑定好输入和输出，形成一个函数（如train，predict） TensorFlowfrom __future__ import print_function import tensorflow as tf from tensorflow.examples.tutorials.mnist import input_data # number 1 to 10 data mnist = input_data.read_data_sets(&#39;MNIST_data&#39;, one_hot=True) def compute_accuracy(v_xs, v_ys): global prediction y_pre = sess.run(prediction, feed_dict={xs: v_xs, keep_prob: 1}) correct_prediction = tf.equal(tf.argmax(y_pre,1), tf.argmax(v_ys,1)) accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32)) result = sess.run(accuracy, feed_dict={xs: v_xs, ys: v_ys, keep_prob: 1}) return result def weight_variable(shape): initial = tf.truncated_normal(shape, stddev=0.1) return tf.Variable(initial) def bias_variable(shape): initial = tf.constant(0.1, shape=shape) return tf.Variable(initial) def conv2d(x, W): # stride [1, x_movement, y_movement, 1] # Must have strides[0] = strides[3] = 1 return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding=&#39;SAME&#39;) def max_pool_2x2(x): # stride [1, x_movement, y_movement, 1] return tf.nn.max_pool(x, ksize=[1,2,2,1], strides=[1,2,2,1], padding=&#39;SAME&#39;) # define placeholder for inputs to network xs = tf.placeholder(tf.float32, [None, 784])/255. # 28x28 ys = tf.placeholder(tf.float32, [None, 10]) keep_prob = tf.placeholder(tf.float32) x_image = tf.reshape(xs, [-1, 28, 28, 1]) # print(x_image.shape) # [n_samples, 28,28,1] ## conv1 layer ## W_conv1 = weight_variable([5,5, 1,32]) # patch 5x5, in size 1, out size 32 b_conv1 = bias_variable([32]) h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1) # output size 28x28x32 h_pool1 = max_pool_2x2(h_conv1) # output size 14x14x32 ## conv2 layer ## W_conv2 = weight_variable([5,5, 32, 64]) # patch 5x5, in size 32, out size 64 b_conv2 = bias_variable([64]) h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2) # output size 14x14x64 h_pool2 = max_pool_2x2(h_conv2) # output size 7x7x64 ## fc1 layer ## W_fc1 = weight_variable([7*7*64, 1024]) b_fc1 = bias_variable([1024]) # [n_samples, 7, 7, 64] -&gt;&gt; [n_samples, 7*7*64] h_pool2_flat = tf.reshape(h_pool2, [-1, 7*7*64]) h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1) h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob) ## fc2 layer ## W_fc2 = weight_variable([1024, 10]) b_fc2 = bias_variable([10]) prediction = tf.nn.softmax(tf.matmul(h_fc1_drop, W_fc2) + b_fc2) # the error between prediction and real data cross_entropy = tf.reduce_mean(-tf.reduce_sum(ys * tf.log(prediction), reduction_indices=[1])) # loss train_step = tf.train.AdamOptimizer(1e-4).minimize(cross_entropy) sess = tf.Session() # important step # tf.initialize_all_variables() no long valid from # 2017-03-02 if using tensorflow &gt;= 0.12 if int((tf.__version__).split(&#39;.&#39;)[1]) &lt; 12 and int((tf.__version__).split(&#39;.&#39;)[0]) &lt; 1: init = tf.initialize_all_variables() else: init = tf.global_variables_initializer() sess.run(init) for i in range(1000): batch_xs, batch_ys = mnist.train.next_batch(100) sess.run(train_step, feed_dict={xs: batch_xs, ys: batch_ys, keep_prob: 0.5}) if i % 50 == 0: print(compute_accuracy( mnist.test.images[:1000], mnist.test.labels[:1000])) 先搭建计算图，并创建一个sess会话，通过sess.run(train_step, feed_dict={xs: batch_xs, ys: batch_ys, keep_prob: 0.5})这样的形式进行实际训练 Pytorch# library # standard library import os # third-party library import torch import torch.nn as nn import torch.utils.data as Data import torchvision import matplotlib.pyplot as plt # torch.manual_seed(1) # reproducible # Hyper Parameters EPOCH = 1 # train the training data n times, to save time, we just train 1 epoch BATCH_SIZE = 50 LR = 0.001 # learning rate DOWNLOAD_MNIST = False # Mnist digits dataset if not(os.path.exists(&#39;./mnist/&#39;)) or not os.listdir(&#39;./mnist/&#39;): # not mnist dir or mnist is empyt dir DOWNLOAD_MNIST = True train_data = torchvision.datasets.MNIST( root=&#39;./mnist/&#39;, train=True, # this is training data transform=torchvision.transforms.ToTensor(), # Converts a PIL.Image or numpy.ndarray to # torch.FloatTensor of shape (C x H x W) and normalize in the range [0.0, 1.0] download=DOWNLOAD_MNIST, ) # plot one example print(train_data.train_data.size()) # (60000, 28, 28) print(train_data.train_labels.size()) # (60000) plt.imshow(train_data.train_data[0].numpy(), cmap=&#39;gray&#39;) plt.title(&#39;%i&#39; % train_data.train_labels[0]) plt.show() # Data Loader for easy mini-batch return in training, the image batch shape will be (50, 1, 28, 28) train_loader = Data.DataLoader(dataset=train_data, batch_size=BATCH_SIZE, shuffle=True) # pick 2000 samples to speed up testing test_data = torchvision.datasets.MNIST(root=&#39;./mnist/&#39;, train=False) test_x = torch.unsqueeze(test_data.test_data, dim=1).type(torch.FloatTensor)[:2000]/255. # shape from (2000, 28, 28) to (2000, 1, 28, 28), value in range(0,1) test_y = test_data.test_labels[:2000] class CNN(nn.Module): def __init__(self): super(CNN, self).__init__() self.conv1 = nn.Sequential( # input shape (1, 28, 28) nn.Conv2d( in_channels=1, # input height out_channels=16, # n_filters kernel_size=5, # filter size stride=1, # filter movement/step padding=2, # if want same width and length of this image after Conv2d, padding=(kernel_size-1)/2 if stride=1 ), # output shape (16, 28, 28) nn.ReLU(), # activation nn.MaxPool2d(kernel_size=2), # choose max value in 2x2 area, output shape (16, 14, 14) ) self.conv2 = nn.Sequential( # input shape (16, 14, 14) nn.Conv2d(16, 32, 5, 1, 2), # output shape (32, 14, 14) nn.ReLU(), # activation nn.MaxPool2d(2), # output shape (32, 7, 7) ) self.out = nn.Linear(32 * 7 * 7, 10) # fully connected layer, output 10 classes def forward(self, x): x = self.conv1(x) x = self.conv2(x) x = x.view(x.size(0), -1) # flatten the output of conv2 to (batch_size, 32 * 7 * 7) output = self.out(x) return output, x # return x for visualization cnn = CNN() print(cnn) # net architecture optimizer = torch.optim.Adam(cnn.parameters(), lr=LR) # optimize all cnn parameters loss_func = nn.CrossEntropyLoss() # the target label is not one-hotted # following function (plot_with_labels) is for visualization, can be ignored if not interested from matplotlib import cm try: from sklearn.manifold import TSNE; HAS_SK = True except: HAS_SK = False; print(&#39;Please install sklearn for layer visualization&#39;) def plot_with_labels(lowDWeights, labels): plt.cla() X, Y = lowDWeights[:, 0], lowDWeights[:, 1] for x, y, s in zip(X, Y, labels): c = cm.rainbow(int(255 * s / 9)); plt.text(x, y, s, backgroundcolor=c, fontsize=9) plt.xlim(X.min(), X.max()); plt.ylim(Y.min(), Y.max()); plt.title(&#39;Visualize last layer&#39;); plt.show(); plt.pause(0.01) plt.ion() # training and testing for epoch in range(EPOCH): for step, (b_x, b_y) in enumerate(train_loader): # gives batch data, normalize x when iterate train_loader output = cnn(b_x)[0] # cnn output loss = loss_func(output, b_y) # cross entropy loss optimizer.zero_grad() # clear gradients for this training step loss.backward() # backpropagation, compute gradients optimizer.step() # apply gradients if step % 50 == 0: test_output, last_layer = cnn(test_x) pred_y = torch.max(test_output, 1)[1].data.numpy() accuracy = float((pred_y == test_y.data.numpy()).astype(int).sum()) / float(test_y.size(0)) print(&#39;Epoch: &#39;, epoch, &#39;| train loss: %.4f&#39; % loss.data.numpy(), &#39;| test accuracy: %.2f&#39; % accuracy) if HAS_SK: # Visualization of trained flatten layer (T-SNE) tsne = TSNE(perplexity=30, n_components=2, init=&#39;pca&#39;, n_iter=5000) plot_only = 500 low_dim_embs = tsne.fit_transform(last_layer.data.numpy()[:plot_only, :]) labels = test_y.numpy()[:plot_only] plot_with_labels(low_dim_embs, labels) plt.ioff() # print 10 predictions from test data test_output, _ = cnn(test_x[:10]) pred_y = torch.max(test_output, 1)[1].data.numpy() print(pred_y, &#39;prediction number&#39;) print(test_y[:10].numpy(), &#39;real number&#39;) 动态搭建网络，一般数据导入，网络搭建 损失函数，训练都是用各自的模块完成。通过继承封装好的父类，如nn.Module进行网络搭建，torch.utils.data.Dataset导入数据等等 Keras# to try tensorflow, un-comment following two lines # import os # os.environ[&#39;KERAS_BACKEND&#39;]=&#39;tensorflow&#39; import numpy as np np.random.seed(1337) # for reproducibility from keras.datasets import mnist from keras.utils import np_utils from keras.models import Sequential from keras.layers import Dense, Activation, Convolution2D, MaxPooling2D, Flatten from keras.optimizers import Adam # download the mnist to the path &#39;~/.keras/datasets/&#39; if it is the first time to be called # training X shape (60000, 28x28), Y shape (60000, ). test X shape (10000, 28x28), Y shape (10000, ) (X_train, y_train), (X_test, y_test) = mnist.load_data() # data pre-processing X_train = X_train.reshape(-1, 1,28, 28)/255. X_test = X_test.reshape(-1, 1,28, 28)/255. y_train = np_utils.to_categorical(y_train, num_classes=10) y_test = np_utils.to_categorical(y_test, num_classes=10) # Another way to build your CNN model = Sequential() # Conv layer 1 output shape (32, 28, 28) model.add(Convolution2D( batch_input_shape=(None, 1, 28, 28), filters=32, kernel_size=5, strides=1, padding=&#39;same&#39;, # Padding method data_format=&#39;channels_first&#39;, )) model.add(Activation(&#39;relu&#39;)) # Pooling layer 1 (max pooling) output shape (32, 14, 14) model.add(MaxPooling2D( pool_size=2, strides=2, padding=&#39;same&#39;, # Padding method data_format=&#39;channels_first&#39;, )) # Conv layer 2 output shape (64, 14, 14) model.add(Convolution2D(64, 5, strides=1, padding=&#39;same&#39;, data_format=&#39;channels_first&#39;)) model.add(Activation(&#39;relu&#39;)) # Pooling layer 2 (max pooling) output shape (64, 7, 7) model.add(MaxPooling2D(2, 2, &#39;same&#39;, data_format=&#39;channels_first&#39;)) # Fully connected layer 1 input shape (64 * 7 * 7) = (3136), output shape (1024) model.add(Flatten()) model.add(Dense(1024)) model.add(Activation(&#39;relu&#39;)) # Fully connected layer 2 to shape (10) for 10 classes model.add(Dense(10)) model.add(Activation(&#39;softmax&#39;)) # Another way to define your optimizer adam = Adam(lr=1e-4) # We add metrics to get more results you want to see model.compile(optimizer=adam, loss=&#39;categorical_crossentropy&#39;, metrics=[&#39;accuracy&#39;]) print(&#39;Training ------------&#39;) # Another way to train the model model.fit(X_train, y_train, epochs=1, batch_size=64,) print(&#39;\\nTesting ------------&#39;) # Evaluate the model with the metrics we defined earlier loss, accuracy = model.evaluate(X_test, y_test) print(&#39;\\ntest loss: &#39;, loss) print(&#39;\\ntest accuracy: &#39;, accuracy) Keras基于Theano或TensorFlow的内核，形成了更高层的封装，有点类似Pytorch。通过model.compile()绑定模型、损失函数和优化器，并通过model.fit即可进行训练 总结这四种框架各自都在不断地自我完善推陈出新，像是目前TensorFlow 2已经把Keras合并进来了，Keras用户迁移过来也十分简单，Pytorch也在不断地让自身更简洁，如去掉了Variable变量的使用等。目前而言，TensorFlow 和 Pytorch 是两大巨头，个人感觉企业用 TensorFlow 更多，高校用 Pytorch 更多吧。","categories":[],"tags":[]},{"title":"强化学习简介","slug":"RL","date":"2020-05-27T11:34:29.000Z","updated":"2020-05-27T14:55:21.850Z","comments":true,"path":"2020/05/27/RL/","link":"","permalink":"http://weiquanfan.xyz/2020/05/27/RL/","excerpt":"","text":"前言强化学习是机器学习中的一大类，它可以让机器学着如何在环境中拿到高分, 表现出优秀的成绩. 而这些成绩背后却是他所付出的辛苦劳动, 不断的试错, 不断地尝试, 累积经验, 学习经验. 强化学习的方法可以分为理不理解所处环境。不理解环境，环境给什么就是什么，称为model-free，包含 Q learning, Sarsa, Policy Gradients 等方法。 理解环境，用多一个模型去表示环境，就是 model-based 方法。 OpenAI gym 环境库是一个编写好了多种交互环境的库，而自己编写环境是一个很耗时间的过程，以下均不涉及环境的编写。 Q learningQ learning 是一种model-free方法，它的核心在于构建一个Q表，这个表表示了处于每一种状态(state)时进行各个行动(action)的奖励值。 举例而言(莫烦python的例子)，下图就是一个强化学习的过程，有16个state(位置)，4个可选的action(上下左右)。让探索者(红框)学会走迷宫. 黄色的是天堂 (reward 1), 黑色的地狱 (reward -1)。 那么，Q learning 的流程如下。 包含了不断重复的三个步骤。 给定当前状态s和Q表， 使用贪婪算法采取一个行动a 给定当前状态s和行动a，由环境交互给出下一个状态s’和奖励r 由s、s’、a、Q表，更新得到新的Q表每次更新我们都用到了 Q 现实和 Q 估计, 而且 Q learning 的迷人之处就是 在 Q(s1, a2) 现实 中, 也包含了一个 Q(s2) 的最大估计值, 将对下一步的衰减的最大估计和当前所得到的奖励当成这一步的现实. 代码如下： import numpy as np import pandas as pd class QLearningTable: def __init__(self, actions, learning_rate=0.01, reward_decay=0.9, e_greedy=0.9): self.actions = actions # a list self.lr = learning_rate self.gamma = reward_decay self.epsilon = e_greedy self.q_table = pd.DataFrame(columns=self.actions, dtype=np.float64) def choose_action(self, observation): self.check_state_exist(observation) # action selection if np.random.uniform() &lt; self.epsilon: # choose best action state_action = self.q_table.loc[observation, :] # some actions may have the same value, randomly choose on in these actions action = np.random.choice(state_action[state_action == np.max(state_action)].index) else: # choose random action action = np.random.choice(self.actions) return action def learn(self, s, a, r, s_): self.check_state_exist(s_) q_predict = self.q_table.loc[s, a] if s_ != &#39;terminal&#39;: q_target = r + self.gamma * self.q_table.loc[s_, :].max() # next state is not terminal else: q_target = r # next state is terminal self.q_table.loc[s, a] += self.lr * (q_target - q_predict) # update def check_state_exist(self, state): if state not in self.q_table.index: # append new state to q table self.q_table = self.q_table.append( pd.Series( [0]*len(self.actions), index=self.q_table.columns, name=state, ) ) from maze_env import Maze from RL_brain import QLearningTable def update(): for episode in range(100): # initial observation observation = env.reset() while True: # fresh env env.render() # RL choose action based on observation action = RL.choose_action(str(observation)) # RL take action and get next observation and reward observation_, reward, done = env.step(action) # RL learn from this transition RL.learn(str(observation), action, reward, str(observation_)) # swap observation observation = observation_ # break while loop when end of this episode if done: break # end of game print(&#39;game over&#39;) env.destroy() if __name__ == &quot;__main__&quot;: env = Maze() RL = QLearningTable(actions=list(range(env.n_actions))) env.after(100, update) env.mainloop() SarsaSarsa 和 Q learning 很类似，差别在于Sarsa会更‘胆小’一点，不太敢尝试。它的流程如下。 可以看出，它和 Q learning 差别仅在于更新环节，具体来讲： 他在当前 state 已经想好了 state 对应的 action, 而且想好了 下一个 state_ 和下一个 action_ (Qlearning 还没有想好下一个 action_) 更新 Q(s,a) 的时候基于的是下一个贪婪算法的 Q(s_, a_) (Qlearning 是基于 maxQ(s_))这种不同之处使得 Sarsa 相对于 Qlearning, 更加的胆小. 因为 Qlearning 永远都是想着 maxQ 最大化, 因为这个 maxQ 而变得贪婪, 不考虑其他非 maxQ 的结果. 我们可以理解成 Qlearning 是一种贪婪, 大胆, 勇敢的算法, 对于错误, 死亡并不在乎. 而 Sarsa 是一种保守的算法, 他在乎每一步决策, 对于错误和死亡比较铭感. import numpy as np import pandas as pd class RL(object): def __init__(self, action_space, learning_rate=0.01, reward_decay=0.9, e_greedy=0.9): self.actions = action_space # a list self.lr = learning_rate self.gamma = reward_decay self.epsilon = e_greedy self.q_table = pd.DataFrame(columns=self.actions, dtype=np.float64) def check_state_exist(self, state): if state not in self.q_table.index: # append new state to q table self.q_table = self.q_table.append( pd.Series( [0]*len(self.actions), index=self.q_table.columns, name=state, ) ) def choose_action(self, observation): self.check_state_exist(observation) # action selection if np.random.rand() &lt; self.epsilon: # choose best action state_action = self.q_table.loc[observation, :] # some actions may have the same value, randomly choose on in these actions action = np.random.choice(state_action[state_action == np.max(state_action)].index) else: # choose random action action = np.random.choice(self.actions) return action def learn(self, *args): pass # off-policy class QLearningTable(RL): def __init__(self, actions, learning_rate=0.01, reward_decay=0.9, e_greedy=0.9): super(QLearningTable, self).__init__(actions, learning_rate, reward_decay, e_greedy) def learn(self, s, a, r, s_): self.check_state_exist(s_) q_predict = self.q_table.loc[s, a] if s_ != &#39;terminal&#39;: q_target = r + self.gamma * self.q_table.loc[s_, :].max() # next state is not terminal else: q_target = r # next state is terminal self.q_table.loc[s, a] += self.lr * (q_target - q_predict) # update # on-policy class SarsaTable(RL): def __init__(self, actions, learning_rate=0.01, reward_decay=0.9, e_greedy=0.9): super(SarsaTable, self).__init__(actions, learning_rate, reward_decay, e_greedy) def learn(self, s, a, r, s_, a_): self.check_state_exist(s_) q_predict = self.q_table.loc[s, a] if s_ != &#39;terminal&#39;: q_target = r + self.gamma * self.q_table.loc[s_, a_] # next state is not terminal else: q_target = r # next state is terminal self.q_table.loc[s, a] += self.lr * (q_target - q_predict) # update from maze_env import Maze from RL_brain import SarsaTable def update(): for episode in range(100): # 初始化环境 observation = env.reset() # Sarsa 根据 state 观测选择行为 action = RL.choose_action(str(observation)) while True: # 刷新环境 env.render() # 在环境中采取行为, 获得下一个 state_ (obervation_), reward, 和是否终止 observation_, reward, done = env.step(action) # 根据下一个 state (obervation_) 选取下一个 action_ action_ = RL.choose_action(str(observation_)) # 从 (s, a, r, s, a) 中学习, 更新 Q_tabel 的参数 ==&gt; Sarsa RL.learn(str(observation), action, reward, str(observation_), action_) # 将下一个当成下一步的 state (observation) and action observation = observation_ action = action_ # 终止时跳出循环 if done: break # 大循环完毕 print(&#39;game over&#39;) env.destroy() if __name__ == &quot;__main__&quot;: env = Maze() RL = SarsaTable(actions=list(range(env.n_actions))) env.after(100, update) env.mainloop() Deep Q Network(DQN)DQN 是一种结合了神经网络的强化学习。普通的强化学习中需要生成一个Q表，而如果状态数太多的话Q表也极为耗内存，所以 DQN 提出了用神经网络来代替Q表的功能。网络输入一个状态，输出各个动作的Q值。网络通过对Q估计和Q现实使用RMSprop来更新参数。Q估计就是网络输出，而Q现实等于奖励+下一状态的前模型的Q估计。流程图如下： 整个算法乍看起来很复杂, 不过我们拆分一下, 就变简单了. 也就是个 Q learning 主框架上加了些装饰，包括: 记忆库 (用于重复学习) 神经网络计算 Q 值 暂时冻结 q_target 参数 (切断相关性) 具体而言，记忆库是通过存储一堆数据在一个不断更新的记忆库里，训练时随机抽取数据出来训练。神经网络用来针对输入的状态来输出采取各个行动的Q值。共用了两个网络，他们的结构一模一样，但 q_target 网络用的是主网络之前很多个step的参数，这是为了形成一种延迟，切断他们的相关性。 import numpy as np import pandas as pd import tensorflow as tf np.random.seed(1) tf.set_random_seed(1) # Deep Q Network off-policy class DeepQNetwork: def __init__( self, n_actions, n_features, learning_rate=0.01, reward_decay=0.9, e_greedy=0.9, replace_target_iter=300, memory_size=500, batch_size=32, e_greedy_increment=None, output_graph=False, ): self.n_actions = n_actions self.n_features = n_features self.lr = learning_rate self.gamma = reward_decay self.epsilon_max = e_greedy self.replace_target_iter = replace_target_iter self.memory_size = memory_size self.batch_size = batch_size self.epsilon_increment = e_greedy_increment self.epsilon = 0 if e_greedy_increment is not None else self.epsilon_max # total learning step self.learn_step_counter = 0 # initialize zero memory [s, a, r, s_] self.memory = np.zeros((self.memory_size, n_features * 2 + 2)) # consist of [target_net, evaluate_net] self._build_net() t_params = tf.get_collection(&#39;target_net_params&#39;) e_params = tf.get_collection(&#39;eval_net_params&#39;) self.replace_target_op = [tf.assign(t, e) for t, e in zip(t_params, e_params)] self.sess = tf.Session() if output_graph: # $ tensorboard --logdir=logs # tf.train.SummaryWriter soon be deprecated, use following tf.summary.FileWriter(&quot;logs/&quot;, self.sess.graph) self.sess.run(tf.global_variables_initializer()) self.cost_his = [] def _build_net(self): # ------------------ build evaluate_net ------------------ self.s = tf.placeholder(tf.float32, [None, self.n_features], name=&#39;s&#39;) # input self.q_target = tf.placeholder(tf.float32, [None, self.n_actions], name=&#39;Q_target&#39;) # for calculating loss with tf.variable_scope(&#39;eval_net&#39;): # c_names(collections_names) are the collections to store variables c_names, n_l1, w_initializer, b_initializer = \\ [&#39;eval_net_params&#39;, tf.GraphKeys.GLOBAL_VARIABLES], 10, \\ tf.random_normal_initializer(0., 0.3), tf.constant_initializer(0.1) # config of layers # first layer. collections is used later when assign to target net with tf.variable_scope(&#39;l1&#39;): w1 = tf.get_variable(&#39;w1&#39;, [self.n_features, n_l1], initializer=w_initializer, collections=c_names) b1 = tf.get_variable(&#39;b1&#39;, [1, n_l1], initializer=b_initializer, collections=c_names) l1 = tf.nn.relu(tf.matmul(self.s, w1) + b1) # second layer. collections is used later when assign to target net with tf.variable_scope(&#39;l2&#39;): w2 = tf.get_variable(&#39;w2&#39;, [n_l1, self.n_actions], initializer=w_initializer, collections=c_names) b2 = tf.get_variable(&#39;b2&#39;, [1, self.n_actions], initializer=b_initializer, collections=c_names) self.q_eval = tf.matmul(l1, w2) + b2 with tf.variable_scope(&#39;loss&#39;): self.loss = tf.reduce_mean(tf.squared_difference(self.q_target, self.q_eval)) with tf.variable_scope(&#39;train&#39;): self._train_op = tf.train.RMSPropOptimizer(self.lr).minimize(self.loss) # ------------------ build target_net ------------------ self.s_ = tf.placeholder(tf.float32, [None, self.n_features], name=&#39;s_&#39;) # input with tf.variable_scope(&#39;target_net&#39;): # c_names(collections_names) are the collections to store variables c_names = [&#39;target_net_params&#39;, tf.GraphKeys.GLOBAL_VARIABLES] # first layer. collections is used later when assign to target net with tf.variable_scope(&#39;l1&#39;): w1 = tf.get_variable(&#39;w1&#39;, [self.n_features, n_l1], initializer=w_initializer, collections=c_names) b1 = tf.get_variable(&#39;b1&#39;, [1, n_l1], initializer=b_initializer, collections=c_names) l1 = tf.nn.relu(tf.matmul(self.s_, w1) + b1) # second layer. collections is used later when assign to target net with tf.variable_scope(&#39;l2&#39;): w2 = tf.get_variable(&#39;w2&#39;, [n_l1, self.n_actions], initializer=w_initializer, collections=c_names) b2 = tf.get_variable(&#39;b2&#39;, [1, self.n_actions], initializer=b_initializer, collections=c_names) self.q_next = tf.matmul(l1, w2) + b2 def store_transition(self, s, a, r, s_): if not hasattr(self, &#39;memory_counter&#39;): self.memory_counter = 0 transition = np.hstack((s, [a, r], s_)) # replace the old memory with new memory index = self.memory_counter % self.memory_size self.memory[index, :] = transition self.memory_counter += 1 def choose_action(self, observation): # to have batch dimension when feed into tf placeholder observation = observation[np.newaxis, :] if np.random.uniform() &lt; self.epsilon: # forward feed the observation and get q value for every actions actions_value = self.sess.run(self.q_eval, feed_dict={self.s: observation}) action = np.argmax(actions_value) else: action = np.random.randint(0, self.n_actions) return action def learn(self): # check to replace target parameters if self.learn_step_counter % self.replace_target_iter == 0: self.sess.run(self.replace_target_op) print(&#39;\\ntarget_params_replaced\\n&#39;) # sample batch memory from all memory if self.memory_counter &gt; self.memory_size: sample_index = np.random.choice(self.memory_size, size=self.batch_size) else: sample_index = np.random.choice(self.memory_counter, size=self.batch_size) batch_memory = self.memory[sample_index, :] q_next, q_eval = self.sess.run( [self.q_next, self.q_eval], feed_dict={ self.s_: batch_memory[:, -self.n_features:], # fixed params self.s: batch_memory[:, :self.n_features], # newest params }) # change q_target w.r.t q_eval&#39;s action q_target = q_eval.copy() batch_index = np.arange(self.batch_size, dtype=np.int32) eval_act_index = batch_memory[:, self.n_features].astype(int) reward = batch_memory[:, self.n_features + 1] q_target[batch_index, eval_act_index] = reward + self.gamma * np.max(q_next, axis=1) &quot;&quot;&quot; For example in this batch I have 2 samples and 3 actions: q_eval = [[1, 2, 3], [4, 5, 6]] q_target = q_eval = [[1, 2, 3], [4, 5, 6]] Then change q_target with the real q_target value w.r.t the q_eval&#39;s action. For example in: sample 0, I took action 0, and the max q_target value is -1; sample 1, I took action 2, and the max q_target value is -2: q_target = [[-1, 2, 3], [4, 5, -2]] So the (q_target - q_eval) becomes: [[(-1)-(1), 0, 0], [0, 0, (-2)-(6)]] We then backpropagate this error w.r.t the corresponding action to network, leave other action as error=0 cause we didn&#39;t choose it. &quot;&quot;&quot; # train eval network _, self.cost = self.sess.run([self._train_op, self.loss], feed_dict={self.s: batch_memory[:, :self.n_features], self.q_target: q_target}) self.cost_his.append(self.cost) # increasing epsilon self.epsilon = self.epsilon + self.epsilon_increment if self.epsilon &lt; self.epsilon_max else self.epsilon_max self.learn_step_counter += 1 def plot_cost(self): import matplotlib.pyplot as plt plt.plot(np.arange(len(self.cost_his)), self.cost_his) plt.ylabel(&#39;Cost&#39;) plt.xlabel(&#39;training steps&#39;) plt.show() from maze_env import Maze from RL_brain import DeepQNetwork def run_maze(): step = 0 # 用来控制什么时候学习 for episode in range(300): # 初始化环境 observation = env.reset() while True: # 刷新环境 env.render() # DQN 根据观测值选择行为 action = RL.choose_action(observation) # 环境根据行为给出下一个 state, reward, 是否终止 observation_, reward, done = env.step(action) # DQN 存储记忆 RL.store_transition(observation, action, reward, observation_) # 控制学习起始时间和频率 (先累积一些记忆再开始学习) if (step &gt; 200) and (step % 5 == 0): RL.learn() # 将下一个 state_ 变为 下次循环的 state observation = observation_ # 如果终止, 就跳出循环 if done: break step += 1 # 总步数 # end of game print(&#39;game over&#39;) env.destroy() if __name__ == &quot;__main__&quot;: env = Maze() RL = DeepQNetwork(env.n_actions, env.n_features, learning_rate=0.01, reward_decay=0.9, e_greedy=0.9, replace_target_iter=200, # 每 200 步替换一次 target_net 的参数 memory_size=2000, # 记忆上限 # output_graph=True # 是否输出 tensorboard 文件 ) env.after(100, run_maze) env.mainloop() RL.plot_cost() # 观看神经网络的误差曲线 总结强化学习本身是不依赖于深度学习的，它更多的是一种思想，通过行为与环境的交互产生奖励值，从而来更新Q表(或相同功能的神经网络)。它没有一种固定的代码，只有一套模式，具体代码还得根据实际应用与交互环境来编写。","categories":[{"name":"强化学习","slug":"强化学习","permalink":"http://weiquanfan.xyz/categories/强化学习/"}],"tags":[{"name":"强化学习","slug":"强化学习","permalink":"http://weiquanfan.xyz/tags/强化学习/"}]},{"title":"使用BeautifulSoup、requests和you_get爬虫下载B站视频","slug":"BeautifulSoup","date":"2020-05-19T12:13:21.000Z","updated":"2020-05-19T12:36:15.497Z","comments":true,"path":"2020/05/19/BeautifulSoup/","link":"","permalink":"http://weiquanfan.xyz/2020/05/19/BeautifulSoup/","excerpt":"","text":"前言BeautifulSoup 是一个可以从HTML或XML文件中提取数据并解析的Python库， Requests 是一常用的可以获取和发送http的请求库， you_get 则是方便的下载各大网站的视频的命令行工具。整体流程上是，先用 Requests 请求获得网站源代码，再用 BeautifulSoup 解析网站并筛选出自己要的信息（如视频的url），最后用 you_get 下载。 例子以下代码实现的是下载B站电影。 #!/usr/bin/env python3 # -*- coding: utf-8 -*- &quot;&quot;&quot; Created on Sun Mar 15 12:06:21 2020 @author: weiquan fan &quot;&quot;&quot; from bs4 import BeautifulSoup as bs import requests,re,os def download(url, filename): path_root = &#39;./Videos&#39; os.system(&#39;you-get -o {} -O {} {}&#39;.format(path_root, filename, url)) url_base = &#39;https://www.bilibili.com/movie/?spm_id_from=333.851.b_62696c695f7265706f72745f6d6f766965.2&#39; response = requests.get(url_base) page = response.text soup = bs(page, &#39;html.parser&#39;) vids = soup.findAll(&#39;li&#39;,attrs={&#39;class&#39;:re.compile(&#39;video-item-biref.*?&#39;)})# bilibili video_urls = [] counter=1 if(vids): for v in vids: #v_link = v.find(&#39;a&#39;)[&#39;href&#39;] #v_name = v.find(&#39;img&#39;)[&#39;alt&#39;] print(v) v_link = v.find(&#39;a&#39;)[&#39;href&#39;] v_name = v.find(&#39;img&#39;)[&#39;alt&#39;] video_urls.append([v_link, v_name]) print(v_link,v_name) try: download(v_link, v_name) except Exception: print(&#39;can\\&#39;t download &#39;+v_name+&#39; in &#39;+v_link) counter -= 1 counter += 1 if(counter&gt;15): break","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://weiquanfan.xyz/categories/爬虫/"}],"tags":[]},{"title":"CNN的进击之路——讲讲ResNet, Inception, ResNeXt和Densenet等常见网络","slug":"resnet","date":"2020-05-13T06:50:15.000Z","updated":"2020-05-13T16:51:28.692Z","comments":true,"path":"2020/05/13/resnet/","link":"","permalink":"http://weiquanfan.xyz/2020/05/13/resnet/","excerpt":"","text":"前言本文是一篇大杂烩，按照发布时间总结了CNN的一些常见网络。 AlexNetAlexNet来源于ImageNet Classification with Deep Convolutional Neural Networks。在ImageNet LSVRC-2010上以远超第二的准确率夺得了冠军，拉开了深度学习热潮的大幕。 模型结构： 模型特点： 提出了非线性激活函数ReLU (之前普遍使用Sigmoid或者tanh) 提出Dropout（每次迭代训练时随机删除一些神经元） 重叠池化（池化的时候，每次移动的步长小于池化的窗口长度） 数据扩充（水平翻转图像，从原始图像中随机裁剪、平移变换，颜色、光照变换） LRN归一化层（利用临近的数据做归一化） 多GPU实现（受当时GPU限制，在每个GPU中放置一半神经元，将网络分布在两个GPU上进行并行计） VGGVGG来源于Oxford的Visual Geometry Group的组提出的Very Deep Convolutional Networks for Large-Scale Image Recognition，在ILSVRC 2014获得亚军。 模型结构： 其中D、E列就是著名的VGG-16、VGG-19。 模型特点：使用了3个3x3卷积核来代替7x7卷积核，使用了2个3x3卷积核来代替5x5卷积核。因此模型结构很统一简洁（卷积核尺寸3x3和最大池化尺寸2x2），并不断加深网络。 GoogLeNet V1GoogLeNet V1来源于Going deeper with convolutions，在ILSVRC 2014获得冠军。 该网络的核心在于提出了Inception Module。该模块有4个分支，初始版本如下图左，包含三个不同尺度的卷积核层和一个最大池化层，并在输出通道维度上合并。由于5×5的计算量大，就进一步先通过1×1卷积降低维度再通过大卷积核。这里的最大池化也是重叠池化的，经padding后不会缩小特征图尺寸。 模型结构： 模型特点： 多尺度卷积的思想让网络变宽 提出1×1卷积 GoogLeNet V2GoogLeNet V2来源于Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift。该网络基于V1版本，吸收了VGG的分解操作，使用了2个3x3卷积核来代替5x5卷积核。 模型特点： 提出了著名的BN层。 另外，为了适配BN层，增大学习速率并加快学习衰减速度以适用BN规范化后的数据；去除Dropout并减轻L2正则（因BN已起到正则化的作用）；去除LRN；更彻底地对训练样本进行shuffle；减少数据增强过程中对数据的光学畸变（因为BN训练更快，每个样本被训练的次数更少，因此更真实的样本对训练更有帮助）。 GoogLeNet V3GoogLeNet V3来源于Rethinking the Inception Architecture for Computer Vision。该网络基于V2版本，进一步改进了Inception，将3x3分解成1x3和3x1。同理，nxn可以分解成1xn和nx1。 ResNetResNet来源于大神何凯明的Deep Residual Learning for Image Recognition，在ILSVRC和COCO 2015上都夺得了冠军，有着里程碑的意义。 深度模型当深度到了几十层之后，由于梯度消失或者爆炸的原因，就容易发生退化问题：网络深度增加时，网络准确度出现饱和，甚至出现下降。现在假设我们有一个浅层网络，我们想通过向上堆积新层来建立深层网络，一个极端情况是这些增加的层什么也不学习，仅仅复制浅层网络的特征，即这样新层是恒等映射（Identity mapping）。在这种情况下，深层网络应该至少和浅层网络性能一样，也不应该出现退化现象。这引发了残差学习，即我们的目标是学习到残差F(x)=H(x)-x，则该层学习到的最终特征H(x)=F(x)+x。当残差为0时，此时堆积层仅仅做了恒等映射，至少网络性能不会下降，实际上残差不会为0，这也会使得堆积层在输入特征基础上学习到新的特征，从而拥有更好的性能。残差学习的结构下图所示。这有点类似与电路中的“短路”，所以是一种短路连接（shortcut connection）。 模型结构：ResNet网络参考VGG19网络，引入残差单元。如下图，第三列即是ResNet-34。 模型特点： 提出残差模块 模型开始变得很深，可以达到152层 卷积层由Conv+BN+ReLU变成BN+ReLU+Conv GoogLeNet V4GoogLeNet V4来源于Inception-v4, Inception-ResNet and the Impact of Residual Connections on Learning。该论文一方面沿袭v3版本，使用更多的Inception module得到GoogLeNet V4。另一方面吸收了ResNet的残差单元，提出了两种Inception-ResNet。 模型结构：下图为其中一种，Inception-ResNet-v1，具有如下特点： Inception module都是简化版，没有使用那么多的分支，因为identity部分（直接相连的线）本身包含丰富的特征信息； Inception module每个分支都没有使用pooling； 每个Inception module最后都使用了一个1x1的卷积（linear activation），作用是保证identity部分和Inception部分输出特征维度相同，这样才能保证两部分特征能够相加。 模型特点： 使得宽模型变得更深 DenseNetDenseNet来源于Densely Connected Convolutional Networks，斩获了CVPR 2017的最佳论文奖。 模型结构：DenseNet有点类似于ResNet，但本质上又有很大的不同。结构上，把以前所有层的特征图都沿着通道轴拼接起来（而不是相加）。这可以理解为充分利用产生过的特征。 如下为ResNet： 如下为DenseNet： 模型特点： 建立了不同层的连接关系，充分利用特征图 MobileNetMobileNet来源于Google提出的MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applications，是一种小巧而高效的CNN模型。 模型结构：MobileNet的核心在于提出了深度可分离卷积，它把传统卷积分解成了深度卷积(depthwise convolution)和逐点卷积(pointwise convolution)，从而大量减少参数量。 对于输入特征图(DF,DF,M)，输出特征图(DG,DG,N)，传统卷积核的尺寸为(K,K,M,N)，如下图(a)。而对于深度可分离卷积，深度卷积的尺寸为(K,K,1,M)，它将这M个卷积核各自应用于输入特征图的各个通道（这与传统卷积不同，这里相乘后不需要沿着通道轴相加），输出特征为(DG,DG,M)，如(b)所示。逐点卷积的尺寸为(1,1,M,N)，这个就是普通的1×1卷积了，输出特征为(DG,DG,N)，如(c)所示。可以看到，参数量从（K×K×M×N）变成（K×K×1×M + 1×1×M×N），减小了 M(KKN - KK -N)。 模型特点： 轻型模型，可用于移动端 ResNeXtResNeXt来源于Aggregated Residual Transformations for Deep Neural Networks。它是基于ResNet，吸收了GoogLeNet的Inception，所以和谷歌的Inception-ResNet很像。 模型结构：如下图，左图是是ResNet，右图是新的ResNeXt。 该结构可以做如下等效，第三种就是等效的分组结构。 模型特点： ResNeXt的分支的拓扑结构是相同的，而Inception V4需要人工设计 提出了一种介于普通卷积核深度可分离卷积的这种策略：分组卷积 XceptionXception来源于Xception: Deep Learning with Depthwise Separable Convolutions。它是Inception-V3的另一种改进，吸收了深度可分离卷积，造就了一种参数量相对少一些的网络结构。 模型结构：Inception-V3可做如下简化，可以看到，如下图和深度可分离卷积是很像的，只是下图是先进行1×1的卷积，再进行channel-wise的spatial convolution，最后concat，而后者是先进行一个channel-wise的spatial convolution，然后是1×1的卷积。所以作者干脆把它换成深度可分离卷积。 最终整体结构如下，其中SeparalbeConv即是深度可分离卷积。 模型特点： 虽然使用了深度可分离卷积，但网络也加宽了，总体参数量和Inception-V3差不多，性能提升了。 提出时间和MobileNet相近，它们从不同的角度揭示了深度可分离卷积的强大作用，MobileNet的思路是通过将 3×3 卷积拆分的形式来减少参数数量，而Xception是通过对Inception的充分解耦来完成的。 ShuffleNetXception来源于ShuffleNet: An Extremely Efficient Convolutional Neural Network for Mobile Devices。这也是一款效率极高的轻型CNN模型，通过逐点群卷积(pointwise group convolution)和通道混洗(channel shuffle)大大降低计算量。 模型结构：如下图左是普通的分组卷积，但是经过多层分组卷积后某个输出channel仅仅来自输入channel的一小部分，学出来的特征也很局限，因此作者提出了通道混洗channel shuffle，过程如下图中，在进行GConv2之前，对其输入feature map做一个分配，也就是每个group分成几个subgroup，然后将不同group的subgroup作为GConv2的一个group的输入，使得GConv2的每一个group都能卷积输入的所有group的feature map，结果图下图右。 pointwise group convolution，其实就是带group的卷积核为1×1的卷积。下图左是一个深度可分离卷积，而中间的图则是一个使用了pointwise group convolution的ShuffleNet unit，它将1×1卷积变成分组卷积，并在第一组分组卷积后加上通道混洗而成。右边的图则是带有降采样的ShuffleNet unit，它一方面在辅分支加入步长为2的3×3平均池化，一方面将最后的相加变成了通道级联。 模型特征： 应用了1×1的通道卷积 提出了通道混洗 总结其实总的来说，创新性的应该包含了inception，残差学习，深度可分离卷积，分组卷积几种。inception有GoogLeNet V1-V4、Xception、ResNeXt。残差学习有ResNet、ResNeXt、DenseNet、GoogLeNet V4。深度可分离卷积有MobileNet、ShuffleNet、Xception。分组卷积有ResNeXt、ShuffleNet。","categories":[{"name":"深度学习模型","slug":"深度学习模型","permalink":"http://weiquanfan.xyz/categories/深度学习模型/"}],"tags":[]},{"title":"cv中Attention的奇妙旅途——讲讲Self-Attention, SENet和CBAM","slug":"SENet","date":"2020-05-08T07:57:04.000Z","updated":"2020-05-08T12:29:06.433Z","comments":true,"path":"2020/05/08/SENet/","link":"","permalink":"http://weiquanfan.xyz/2020/05/08/SENet/","excerpt":"","text":"前言由于注意力机制的高速发展，我尝试着对attention形成一种比较系统化的理解，选了比较有代表性的Self-Attention, SENet和CBAM，整理成本文。 Self-Attention在谷歌发表的Attention Is All You Need之后，Self-Attention开始广为人知。正如我此前对这篇论文的讲解，最终的注意力可以表示为下图，其中Q为Query，K为Key，V为Value，三者都是由输入X经过不同的映射得来的。这个公式可以这么记，先通过相乘得到Query和Key的相似度，而后归一化加softmax成为注意力权重，该权重乘以Value值就是输出的新表达了。 然而，这个公式在这里的输入X的维度是time × embedding，那么怎么用于三维的图像呢？很自然的可以想到，时序信号中的时间可以类比到图像中的空间，那么只需要把长和宽两个维度拉成一个维度，就形成了一行地的空间信息。那么接下来，剩下的通道（单通道或三通道），就可以类比成时序信号中token的embedding。因此，Self-Attention公式在图像上的输入的维度是spatial × channel。那么，图像上的Self-Attention本质上是计算一种空间权重。 SENet2017年Squeeze-and-Excitation Networks获得了ILSVRC的冠军，使得SENet名声大噪。其实这篇论文的核心在于提出了一种很方便嵌入其他模型的模块————SE block。它的结构图如下。前边是传统的卷积操作，得到了特征图U(H x W x C)。而后看上边的支路，共有两个操作，一个是Squeeze一个是Excitation，可以得到一串通道上的注意力权重，再把它乘进各个通道，就得到了新的特征图。 Squeeze操作对U进行Global Average Pooling，得到一串(1 x 1 x C)的权重，这里就是注意力的雏形了，比起一开始Self注意力的QK矩阵真是简单粗暴了很多。 Excitation操作也很直接，就是把刚才得到的权重经过两层全连接层（后边带ReLU）再加一层Sigmoid。至于两层全连接的神经元数？第一层是输入C个而输出C/r个神经元，第二次则是输入C/r而输出C个神经元。可以看成一种压缩再恢复的过程，r表示压缩程度。作者的实验表明r取16时效果比较好。所以，图像上的SENet本质上是计算一种通道权重。 CBAM现在我们知道了有空间的注意力，有通道的注意力，那么也可以想到一种两者都有的注意力。CBAM: Convolutional Block Attention Module就干了这么一件事。它也是一种可嵌入的模块，结构图如下,包含通道注意力模块和空间注意力模块。 这里分别讲解这两种模块。 通道注意力模块 通道注意力模块其实基本就是SE block，不同点在于除了SE用的AvgPool之外还用了MaxPool，相当于有两种Squeeze方式，而后得到的两串注意力雏形各自同样经过两层带ReLU的全连接层（注意这里avg和max使用的全连接是共享的，有点奇怪，个人感觉不共享会好一些），相加起来再经过Sigmoid，就得到了通道上的注意力，然后乘回去得到了通道上更新了的特征图。 空间注意力模块 空间注意力模块可以说是用Self的思想和SENet的操作形成的。可以看到，刚才的通道注意力是在空间上进行Pool，那么，空间注意力是不是也可以在通道上进行Pool呢？这就形成了空间注意力模块。首先，它基于通道上进行global max pooling 和global average pooling，得到的两张空间图拼接一下形成2通道，再进行一下卷积(实验表明7 * 7卷积效果好些)降成单通道，类似的经过一个Sigmoid，就得到了空间注意力权重。乘回去就得到了空间上更新了的特征图。 所以，CBAM基于senet的通道注意力，引入空间注意力，本质上是计算了通道和空间的权重。 总结经过这么一个流程可以看到： 注意力就是计算通道(嵌入)和空间(时间)的注意力权重，Self是空间，SENet是通道，CBAM是空间加通道。甚至于空间上的注意力还可以拆分，只有横轴的注意力或只有纵轴的注意力，这些都视实际输入的图像需求来选择。 注意力的形式变得简单。一开始的Self需要经过QK矩阵算出一个三维（nlp中是二维，空间拉出长宽就变成了三维）的注意力权重，表示空间上每一个点与空间上所有点的注意力。CBAM中的空间注意力模块，只需经过pooling和一些简单的其它操作即得到了一个二维的注意力权重，表示一种整体上应该关注空间上的哪些位置。","categories":[{"name":"深度学习模型","slug":"深度学习模型","permalink":"http://weiquanfan.xyz/categories/深度学习模型/"}],"tags":[{"name":"attention","slug":"attention","permalink":"http://weiquanfan.xyz/tags/attention/"}]},{"title":"讲讲横扫nlp任务的BERT模型","slug":"BERT","date":"2020-05-07T08:08:20.000Z","updated":"2020-05-07T12:58:59.538Z","comments":true,"path":"2020/05/07/BERT/","link":"","permalink":"http://weiquanfan.xyz/2020/05/07/BERT/","excerpt":"","text":"前言本文讲解Google在2019年发表的论文BERT: Pre-training of Deep Bidirectional Transformers forLanguage Understanding 。从标题可以看出，该论文基于Transformer模型，提出了一款用于语言理解的预训练模型，并在GLUE, SQuAD等nlp任务中都取得了很好的效果。该模型的创新点实际上不在于模型结构，而在于预训练的方法。以下围绕这两方面都进行一些讲解。 模型结构总体框图首先最好还是先理解一下Transfomer，这是BERT模型的基础所在。简而言之，Transfomer包含N个编码器和解码器。编码器将输入序列编码成带有全局新的特征序列，解码器将编码器的特征序列解码成预测结果。BERT使用的正是其中的编码器，模型如下所示。 注意：并不是一个Tm代表一个Transformer，可以看成一行Tm表示一个Transformer的编码器，而编码器也不是两层可以有多层。那么，输入序列送入BERT后，最后一层Tm将对每一个输入token都生成一个新的特征序列，而T则表示任务，一般都是用全连接层来完成分类任务。另外用来对比的是，与GPT是单向的Transformer连接，ELMo是双向的LSTM连接。 Embedding从框图上可以看到，输入序列是各token的embedding。在Transfomer中，这种嵌入由word embedding加上positional embedding而来。而在BERT中，还要额外加上一个segment embedding，用于指示各个token属于输入的第几个句子。这是因为有的nlp任务是输入一对句子的，需要借此加以区分。而且，positional embedding也不是沿用三角函数，三种embedding都是学习出来的。另外，一开始的token，除了要在一开始添加一个起始标志[CLS]之外，还要在不同句子的过渡位置插一个[SEP]标志（如果有多句子的话）。 迁移策略BERT是一个预训练模型，所以我们要怎么拿过来用呢？官方为我们提供了各种任务的应用方法。首先，NLP的下游任务可以分为4类： 句子关系判断：识别蕴含(entailment)、识别语义相似等 分类任务：文本分类、情感计算等 序列标注：分词、实体识别、语义标注等 生成式任务：机器翻译、文本摘要等 图中 (a) 解决的是句子关系判断问题，MultiNLI(识别蕴含，M推理出N，蕴含/矛盾/中立），QQP（识别语义相似），QNLI（识别是否回答了问题），STS-B（识别语义相似），MRPC（识别语义等价，微软）、RTE（识别蕴含，小数据），SWAG（识别回答问题，大数据)。(b) 解决的是分类任务，SST-2（情感计算，斯坦福），CoLA（句子语言性判断，是否能成句）。(c) 解决的是序列标注任务，SQuAD（判断回答的起始和结束时刻，斯坦福问答数据集，从phrase中选取answer）。(d) 解决的是序列标注任务，NER（命名实体识别）。总的来说 (a) 和 (b) 都是分类任务，差别在于输入的是一个句子还是一对句子。这类任务，只需通过在第一个token（即[CLS]标志）的特征序列送入全连接层即可获取识别结果。(c) 和 (d) 都是序列标注任务，这类则在多个token的特征序列送入全连接层，获取各自的标注结果。可以看到，目前只有生成式任务还没有被ko。 p.s. 大名鼎鼎的GLUE任务集则包含了MultiNLI、QQP、QNLI、STS-B、MRPC、RTE、WNLI(也是识别蕴含)、SST-2、CoLA。 预训练方法常见的预训练方法一般是给前面的序列去预测下一个token（像是GPT）。而BERT就提出了两个比较有意思的训练任务 —— Masked LM 和 Next Sentence Prediction。 Masked LM为了实现模型的双向，就不能一直给定前面预测后面，于是作者提出了一个trick。在训练过程中，随机mask掉15%的token，即把相应位置的token替换成一个[MASK]标识，而任务的目标就是要去恢复这个句子（包含MASK的词），而损失函数只考虑了MASK位置的预测值，忽视掉非masked的值。这样，MASK的词可前可后，就实现了模型的双向性。 由此也衍生出了一个问题，就是在实际预测的时候是不会碰到[MASK]的，用了太多[MASK]就容易影响到模型。所以作者又用了个小技巧，选中了要mask的token后，其中10%的token会被替代成其他token，10%的token不替换，剩下的80%才被替换为[MASK]。 Next Sentence Prediction由于nlp中存在需要输入两个句子的句子关系判断任务，所以需要增设一个让模型理解句子之间关系的任务，于是Next Sentence Prediction应运而生。具体而言，就是输入两个句子，由模型来判断这两个句子是不是连续的上下句。其中，为了保持样本平衡性，选了50%的连续的正样本，再随机选50%的无关的负样本。其实这个任务和seq2seq的任务有点异曲同工之妙，只是从单词级别变到了句子级别。举个例子：正样本：今天[MASK]（天气）真好，正好我们[MASK]（出去）吃饭吧。负样本：今天[MASK]（天气）真好，[MASK]（我）吃饱了。 总结其实BERT模型除了提出这两种训练方法外，大量的数据肯定对这个预训练模型有很强的作用，不过一般人没这种计算资源…所以还是很感谢谷歌开源出来的预训练模型，可以很方便的使用并达到非常好的效果。在使用时，如果需要用到自己的数据库上，要么就是完全自己写然后导入BERT模型，要么可以直接使用官方的代码，如run_glue.py，只需要修改数据的预处理，定义好新的类，然后指定类别数等参数，就可以直接使用了。 参考文献https://www.cnblogs.com/rucwxb/p/10277217.htmlhttps://zhuanlan.zhihu.com/p/46652512","categories":[{"name":"深度学习模型","slug":"深度学习模型","permalink":"http://weiquanfan.xyz/categories/深度学习模型/"}],"tags":[{"name":"BERT","slug":"BERT","permalink":"http://weiquanfan.xyz/tags/BERT/"},{"name":"Transformer","slug":"Transformer","permalink":"http://weiquanfan.xyz/tags/Transformer/"},{"name":"GLUE","slug":"GLUE","permalink":"http://weiquanfan.xyz/tags/GLUE/"}]},{"title":"Transfomer以及Self-Attention讲解","slug":"transfomer","date":"2020-05-05T12:23:39.000Z","updated":"2020-05-08T12:30:41.778Z","comments":true,"path":"2020/05/05/transfomer/","link":"","permalink":"http://weiquanfan.xyz/2020/05/05/transfomer/","excerpt":"","text":"前言这一篇主要讲解谷歌发表的Attention Is All You Need。这篇论文提出了驰名的一种注意力机制 —— self-attention 模块，并进一步提出了 Transformer 架构，从而将以往用的计算代价较大的RNN替换掉了。目前，nlp任务中效果非常好的BERT模型就是大量应用了Transformer架构的Encoder。 下图是一个很好的使用Transformer进行机器翻译任务的例子。在预测过程中，编码阶段，输入的“I arrived at the”中的每个单词都会计算与所有单词的注意力权重，并加权求和得出新的自己的表示，逐层编码。解码阶段，输入由encoder出来的所有单词的表示和上一个位置输出的embedding，经过类似的注意力操作得到这一个位置的输出，是一种随着预测位置移动的迭代过程。 总体框架与流程框架对照着以上例子，看下边的Transfomer总体框架图。左边为编码器，右边为解码器。编码器和解码器中都包含了Positional Encoding模块，Multi-Head Attention模块，Feed-Forward模块。下一章节会对此着重讲解。 流程定义一下符号。 emb_dim：嵌入的尺寸 input_length：输入序列的长度 target_length：目标序列的长度+1。+1是因为要移位。 vocab_size：目标词汇表中的单词数量。 则Transformer的流程可表示为： 该模型将每个token表示为维度emb_dim的向量。然后，对于特定的输入序列，我们有了尺寸为（input_length）x（emb_dimb）的矩阵。 然后添加位置信息（位置编码）。与上一步一样，此步骤将返回尺寸为（input_length）x（emb_dim）的矩阵。 数据通过N=6个编码器块。之后，我们获得尺寸为（input_length）x（emb_dim）的矩阵。 目标序列经过等同于1和2的操作，并进行mask屏蔽。输出的尺寸为（target_length）x（emb_dim）。 4的结果经过N=6个解码器块。在每个迭代中，解码器都使用编码器的输出3）。这在总框图中由从编码器到解码器的箭头表示。输出的尺寸为（target_length）x（emb_dim）。 最后，逐行使用全连接层和softmax。输出的尺寸为（target_length）x（vocab_size）。 编码器对于训练阶段和测试阶段是一样的编码过程，而解码器的流程则有所不同，因此先讲解一下解码器的训练和测试。在测试阶段，由于没有groundtruth，所以我们需要从零开始不断迭代一个词一个词地生成。具体操作如下： 计算输入序列的嵌入表示。 使用起始token例如’‘，作为第一个目标序列。该模型将预测输出一个token。 将最后一个预测token添加到目标序列，并使用它生成新的预测。 重复执行步骤3，每次的输入token和输出token都增加，直到预测的token是表示序列结束的token，例如。 在训练阶段中，由于我们事先有roundtruth，因此我们将直接为模型提供整个已移位目标序列，并要求其预测未移位目标。举个例子，目标是将句子从英语翻译成西班牙语：X = [‘Hello’，’，’，’how’，’are’，’you’，’？’]（输入序列）Y = [‘Hola’，’，’，’como’，’estas’， ‘？’]（目标序列）在前面的示例之后，我们将给解码器输入：[‘‘，’Hola’，’，’，’como’，’estas’，’？’]预期的预测将是：[‘Hola’，’，’，’como’，’estas’，’？’，’‘] 因此可以看到，解码器在训练时直接从target_length-&gt;target_length，而测试时则是从1-&gt;1 2-&gt;2 3-&gt;3 … target_length-&gt;target_length的过程，最后预测的是每次迭代中最后一个预测的token串联起来。 Positional EncodingTransformer抛弃了RNN，而RNN最大的优点就是在时间序列上对数据的抽象，所以文章中作者提出两种Positional Encoding的方法，将encoding后的数据与embedding数据求和，加入了相对位置信息。 用不同频率的sine和cosine函数直接计算 学习出一份positional embedding实验后发现两者结果一样，所以用了第一种方法，优点是不需要训练参数，而且即使在训练集中没有出现过的句子长度上也能用 对于输入序列，经过word embedding后，加上positional embedding后即可得到该序列的 representation，序列中的每个token都转换成包含 word 的特征和 word 在句子中的位置信息的向量。 Multi-Head AttentionMulti-Head Attention其实就是多个Self-Attention结构的结合。因此，首先我们需要着重学习论文的重点Self-Attention。 Self-Attention从一个比较知名的例子讲起。假如我们要翻译一个词组Thinking Machines，其中Thinking的输入的embedding vector用x1表示，Machines的embedding vector用x2表示。当我们处理Thinking这个词时，我们需要计算句子中所有词与它的Attention Score，这就像将当前词作为搜索的query，去和句子中所有词（包含该词本身）的key去匹配（点乘），看看相关度有多高。相关度进行尺度缩放与softmax归一化可以得到注意力权重，注意力与相应的value加权求和就得到新的表达。 如果将输入的所有向量合并为矩阵形式，则所有query, key, value向量也可以合并为矩阵形式表示 则上述操作可简化为矩阵形式 这就是著名的注意力公式： Multi-Head Attention基于上边的Self-Attention， 我们进一步拓展，对输入序列使用不同的Q，K，V进行多次以上操作，而后拼接起来，再转换成最终的表示。这样每个head可以学习到在不同表示空间中的特征。 可视化如下： Masked Multi-Head Attention在训练过程的解码器中，需要对输入的注意力矩阵（即上边QK经过softmax的矩阵）进行masked操作，从而不给模型看见未来信息，解决了信息泄露问题。举例来说，对于目标序列（I have a dream），I作为第一个单词，只能有和自身的attention。have作为第二个单词，有和I, have 两个attention。 a 作为第三个单词，有和I,have,a 前面三个单词的attention。到了最后一个单词dream的时候，才有对整个句子4个单词的attention。 其它操作和上述的Multi-Head Attention一致。 Encoder-Decoder Multi-Head Attention在解码器的第二层attention里，需要整合encoder的输入序列和decoder的目标序列的信息，算出相互之间的注意力。与Multi-Head Attention的不同点在于，Encoder-Decoder Multi-Head Attention的Q矩阵来自decoder，而K和V来自encoder。其实也很好理解，就是注意力矩阵是由来自解码器的Query和来自编码器的Key之间计算得来，其它操作都相同。 Feed-Forward这个就很简单了，就是简单的映射层。 Produce Output Probabilities这个其实也是普通的映射层，它将每一个目标序列的token由emb_dim映射到vocab_size，因此就可得到各个token，串成目标序列了。 总结不得不说，这确实是一篇很经典的论文，将seq2seq模型推到了一个新高度，避免了RNN的大量计算代价，从此用CNN操作序列信号就有很好的效果了。另外，Self-Attention还跨界在cv行业也有了非常多的研究。可以说cv和nlp是同源的，只需要将图像的长宽拉成一列（空间信息）类比成序列信号的序列，图像的通道类比成序列信号的embedding即可。因此，Self-Attention模块的输入在nlp上是time × embedding，在cv上是spatial × channel。此外，当下横扫nlp的BERT模型也是基于Transfomer的encoder，这也表明这个模型的重要性了。 参考文献 https://medium.com/dissecting-bert/dissecting-bert-appendix-the-decoder-3b86f66b0e5f https://zhuanlan.zhihu.com/p/80986272 https://zhuanlan.zhihu.com/p/44121378 https://zhuanlan.zhihu.com/p/39034683 https://zhuanlan.zhihu.com/p/47282410","categories":[{"name":"深度学习模型","slug":"深度学习模型","permalink":"http://weiquanfan.xyz/categories/深度学习模型/"}],"tags":[{"name":"Transformer","slug":"Transformer","permalink":"http://weiquanfan.xyz/tags/Transformer/"},{"name":"attention","slug":"attention","permalink":"http://weiquanfan.xyz/tags/attention/"}]},{"title":"常见的梯度下降算法原理","slug":"gradient-descent","date":"2020-05-04T04:58:54.000Z","updated":"2020-05-04T16:45:54.475Z","comments":true,"path":"2020/05/04/gradient-descent/","link":"","permalink":"http://weiquanfan.xyz/2020/05/04/gradient-descent/","excerpt":"","text":"前言梯度下降算法（Gradient Descent Optimization）是神经网络模型训练最常用的优化算法。对于深度学习模型，基本都是采用梯度下降算法来进行优化训练的。梯度下降算法背后的原理：目标函数 $J(\\theta)$ 关于参数 $\\theta$ 的梯度将是损失函数（loss function）上升最快的方向。而我们要最小化loss，只需要将参数沿着梯度相反的方向前进一个步长，就可以实现目标函数（loss function）的下降。这个步长 $\\eta$ 又称为学习速率。 原始的梯度下降Batch gradient descent 批梯度下降，对所有的样本计算梯度后求平均，并更新参数。 因为在执行每次更新时，我们需要在整个数据集上计算所有的梯度，所以批梯度下降法的速度会很慢，同时，批梯度下降法无法处理超出内存容量限制的数据集。批梯度下降法同样也不能在线更新模型，即在运行的过程中，不能增加新的样本。 对于凸误差函数，批梯度下降法能够保证收敛到全局最小值，对于非凸函数，则收敛到一个局部最小值。 SGD 随机梯度下降，对每个样本计算梯度，并更新一次参数。 SGD的运行速度更快 可以用于在线学习 SGD以高方差频繁地更新，导致目标函数出现剧烈波动。 与批梯度下降法的收敛会使得损失函数陷入局部最小相比，由于SGD的波动性，一方面，波动性使得SGD可以跳到新的和潜在更好的局部最优。另一方面，这使得最终收敛到特定最小值的过程变得复杂，因为SGD会一直持续波动。然而，已经证明当我们缓慢减小学习率，SGD与批梯度下降法具有相同的收敛行为，对于非凸优化和凸优化，可以分别收敛到局部最小值和全局最小值。 Mini-batch GD 小批量梯度下降法最终结合了上述两种方法的优点，在每次更新时使用个小批量训练样本 减少参数更新的方差，这样可以得到更加稳定的收敛结果 可以利用最新的深度学习库中高度优化的矩阵优化方法，高效地求解每个小批量数据的梯度。 小结原始的梯度下降方法有以下问题： 在梯度平缓的维度下降非常慢，在梯度险峻的维度容易抖动 容易陷入局部极小值或鞍点。Zero gradient,gradient descent gets stuck （在高维空间中，鞍点比局部极小值更容易出现）-选择一个合适的学习率可能是困难的。学习率太小会导致收敛的速度很慢，学习率太大会妨碍收敛，导致损失函数在最小值附近波动甚至偏离最小值-学习率调整试图在训练的过程中通过例如退火的方法调整学习率，即根据预定义的策略或者当相邻两代之间的下降值小于某个阈值时减小学习率。然而，策略和阈值需要预先设定好，因此无法适应数据集的特点-对所有的参数更新使用同样的学习率。如果数据是稀疏的，同时，特征的频率差异很大时，我们也许不想以同样的学习率更新所有的参数，对于出现次数较少的特征，我们对其执行更大的学习率 带冲量的梯度下降Momentum optimization冲量梯度下降算法是Boris Polyak在1964年提出的，其基于这样一个物理事实：将一个小球从山顶滚下，其初始速率很慢，但在加速度作用下速率很快增加，并最终由于阻力的存在达到一个稳定速率。对于冲量梯度下降算法，其更新方程如下： 可以看到，参数更新时不仅考虑当前梯度值，而且加上了一个积累项（冲量），但多了一个超参，一般取接近1的值如0.9。相比原始梯度下降算法，冲量梯度下降算法有助于加速收敛。当梯度与冲量方向一致时，冲量项会增加，而相反时，冲量项减少，因此冲量梯度下降算法可以减少训练的震荡过程。 Nesterov Accelerated Gradient (NAG)NAG算法是Yurii Nesterov在1983年提出的对冲量梯度下降算法的改进版本，其速度更快。其变化之处在于计算“超前梯度”更新冲量项，具体公式如下： 学习率自适应的梯度下降AdaGradAdaGrad是Duchi在2011年提出的一种学习速率自适应的梯度下降算法。在训练迭代过程，其学习速率是逐渐衰减的，经常更新的参数其学习速率衰减更快，这是一种自适应算法。 其更新过程如下： 把每一维度的梯度^2和记录下来，每次学习率都除以这个和 每一维度的学习率不一样，且都在不断减小 在梯度大的维度，减小下降速度；在梯度小的维度，加快下降速度 让学习率适应参数，对于出现次数较少的特征，我们对其采用更大的学习率，对于出现次数较多的特征，我们对其采用较小的学习率。因此，Adagrad非常适合处理稀疏数据。 Adagrad算法的一个主要优点是无需手动调整学习率 Adagrad的一个主要缺点是它在分母中累加梯度的平方：由于每增加一个正项，在整个训练过程中，累加的和会持续增长。这会导致学习率变小以至于最终变得无限小，在学习率无限小时，Adagrad算法将无法取得额外的信息。 RMSpropRMSprop是Hinton在他的课程上讲到的，其算是对Adagrad算法的改进，主要是解决学习速率过快衰减的问题。其实思路很简单，类似Momentum思想，引入一个超参数，在积累梯度平方项进行衰减： 此时可以看到s是梯度平方的指数加权移动平均值，其中\\gamma一般取值0.9，此时s更平稳，减少了出现的爆炸情况，因此有助于避免学习速率很快下降的问题。同时Hinton也建议学习速率设置为0.001。 Adaptive moment estimation (Adam)Adam是Kingma等在2015年提出的一种新的优化算法，其结合了Momentum和RMSprop算法的思想。相比Momentum算法，其学习速率是自适应的，而相比RMSprop，其增加了冲量项。所以，Adam是两者的结合体： 可以看到前两项和Momentum和RMSprop是非常一致的， 由于和的初始值一般设置为0，在训练初期其可能较小，第三和第四项主要是为了放大它们。最后一项是参数更新。其中超参数的建议值是 总结本文沿着梯度下降的发展大致介绍了各种常用的梯度下降算法，目前比较常用的应该仍是 Adam ， 不过我感觉其实 SGD 加梯度衰减策略可能能取得更好的效果，当然这需要设置得比较合适。 彩蛋","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://weiquanfan.xyz/categories/机器学习/"}],"tags":[]},{"title":"opensmile 工具的使用和批处理","slug":"opensmile","date":"2020-05-02T12:32:13.000Z","updated":"2020-05-03T03:48:28.519Z","comments":true,"path":"2020/05/02/opensmile/","link":"","permalink":"http://weiquanfan.xyz/2020/05/02/opensmile/","excerpt":"","text":"前言openSMILE是一款以命令行形式运行的工具，通过配置config文件来提取音频特征。主要应用于语音识别、情感计算、音乐信息获取。2.0版本之后的openSMILE包括了openCV库，可以用于视频处理和视频特征提取。官网下载有linux和windows版本提供下载，windows可以不编译直接用，建议在命令行里指明 openSMILE 绝对路径。 openSMILE的输入输出格式文件输入格式 RIFF-WAVE (PCM) (for MP3, MP4, OGG, etc. a converter needs to be used) Comma Separated Value (CSV) HTK parameter files WEKA’s ARFF format.（由htk工具产生） Video streams via openCV.（opencv产生的视频流数据） 文件输出格式 RIFF-WAVE (PCM uncompressed audio) Comma Separated Value (CSV) HTK parameter file WEKA ARFF file LibSVM feature file format Binary float matrix format 分类器和其他组件openSMILE还提供了许多VAD算法，用于判断各时间点有没有说话。 Voice Activity Detection based on Fuzzy Logic Voice Activity Detection based on LSTM-RNN with pre-trained models Turn-/Speech-segment detector LibSVM (on-line) LSTM-RNN (Neural Network) classifier which can load RNNLIB and CURRENNT nets GMM (experimental implementation from eNTERFACE’12 project, to be release soon) SVM sink (for loading linear kernel WEKA SMO models) Speech Emotion recognition pre-trained models (openEAR) openSMILE使用流程简介 先切换到处理文件SMILExtract.exe所在的目录 通过如下语句提取：windows下：SMILExtract_Release -C “配置文件” -I “要处理的音频” -O “要保存特征向量的路径及文件名”linux下：SMILExtract -C “配置文件” -I “要处理的音频” -O “要保存特征向量的路径及文件名” 官方配置文件官方提供了许多常见特征集的配置文件，如MFCC，PLP，以及各大语音比赛中效果好的特征集。 MFCC特征为了提取MFCC特征（兼容HTK），提供了以下四个文件（它们是以它们所代表的相应的HTK参数类型命名的）：MFCC12_0_D_A.conf此配置从25毫秒的音频帧中提取梅尔频率倒谱系数（以10毫秒的速率采样）（汉明窗口）。 它由26个Mel频带计算13个MFCC（0-12）组，并应用了一个权重参数为22的倒谱提升滤波器。13个一阶和13个二阶系数被附加到MFCC后。MFCC12_E_D_A.conf此配置跟MFCC12_0_D_A.conf一样，但对数能量是只加在MFCC1-12上。MFCC12_0_D_A_Z.conf这个配置跟MFCC12_0_D_A.conf配置一样，除了所有特征是参考整个输入序列进行了标准化。MFCC12_E_D_A_Z.conf这个配置跟MFCC12_E_D_A.conf配置一样，除了所有特征是参考整个输入序列进行了标准化。帧长为25ms,帧移为10ms，使用的汉明窗，预增强参数为0.97。由26个通过FFT功率谱计算的mel-滤波器组计算MFCC 0/1-12。MEL频谱的频率范围为0-8kHz，同时这些配置文件提供了-I,-O选项。输出文件格式是HTK参数文件格式。如果需要输出其他文件格式，你必须在配置文件中更改‘cHtkSink’组件类型为你想要的类型。命令行示例如下： SMILExtract -C config/MFCC12_E_D_A.conf -I input.wav -O output.mfcc.htk PLP特征用于提取PLP倒谱系数（PLP-CC）（与HTK兼容）以下四个文件（它们是以它们所代表的相应的HTK参数类型命名的）：PLP_0_D_A.conf该配置从25 ms长音频（以10ms的速率采样）帧提取Mel频率倒谱系数（汉明窗口）。它从26个Mel频带，并使用预测阶数为5计算6个PLP（0-5），并应用了一个权重参数为22的倒谱提升滤波器。6个一阶和6个二阶系数被附加到PLP-CC后。PLP_E_D_A.conf该配置与PLP_0_D_A.conf相同，但对数能量是只加在PLP1-12上。PLP_0_D_A_Z.conf此配置与PLP_0_D_A.conf相同，除了所有特征是参考整个输入序列进行了标准化。PLP_E_D_Z.conf此配置与PLP_E_D_A.conf相同，除了所有特征是参考整个输入序列进行了标准化。帧长为25ms,帧移为10ms，使用的汉明窗，预增强参数为0.97。由26个通过FFT功率谱计算的听觉mel-滤波器组(压缩系数为0.33)计算PLP 0/1-5。线性预测器的预测阶数为5。MEL频谱的频率范围为0-8kHz，同时这些配置文件提供了-I,-O选项。输出文件格式是HTK参数文件格式。如果需要输出其他文件格式，你必须在配置文件中更改‘cHtkSink’组件类型为你想要的类型。命令行示例如下： SMILExtract -C config/PLP_E_D_A.conf -I input.wav -O output.plp.htk 情感特征集自openSMILE在openEAR的项目EWS09情感识别中被使用，openSMILE提供了各种情感识别的标准特征集。The INTERSPEECH 2009 Emotion Challenge feature set（参见[SSB09]）由配置文件config/emo IS09.conf提供。它包含对LLDs应用统计函数得到的384个特征。该特征被保存在Arff格式（针对WEKA），新的实例会被附加到一个已存在文件（这是用于批处理，其中openSMILE被反复调用从多个文件提取特征到单个特征文件）。 出现在Arff文件中16个低级描述符（LLDs）的名称，见下面的列表： pcm_RMSenergy 信号帧均方根能量 mfcc 梅尔频率倒谱系数1-12 Pcm_zcr 时间信号的过零率（基于帧） voiceProb 从ACF计算的发声概率。 F0 从倒谱计算的基频 附加到低级描述符名称的后缀_sma表示它们是通过窗口长度为3的移动平均滤波器进行平滑。附加到sma的后缀_de表示当前特征是低级描述符平滑后的一阶delta系数（微分）。 max 轮廓的最大值 min 轮廓的最小值 range = max- min maxPos 最大值的绝对位置（以帧为单位） minPos 最小值的绝对位置（以帧为单位） amean 轮廓的算术平均值 linregc1 轮廓线性逼近的斜率（m） linregc2 轮廓线性逼近的偏移量（t） linregerrQ 计算的二次误差作为线性近似值和实际轮廓的差值 stddev 轮廓上的值的标准偏差 skewness 偏度（3阶矩） kurtosis 峰度（4阶矩） The INTERSPEECH 2010 Paralinguistic Challenge feature set（见2010年INTERSPEECH会议论文集）由配置文件config/IS10_paraling.conf提供。该集包含的1582个特征是由34个低级描述符（LLDs）和34个相应的delta作为68个LLDs轮廓值，在此基础上应用21个函数得到1428个特征，另外，对4个基于音高的LLD及其4个delta系数应用了19个函数得到152个特征，最后附加音高（伪音节）的数量和总数输入的持续时间（2个特征）。该特征被保存在Arff格式（针对WEKA），新的实例会被附加到一个已存在文件（这是用于批处理，其中openSMILE被反复调用从多个文件提取特征到单个特征文件）。 出现在Arff文件中34个低级描述符（LLDs）的名称，见下面的列表： pcm_loudness 归一化强度提高到0.3的幂的响度 mfcc 美尔频率倒谱系数0-14 logMelFreqBand 梅尔频带的对数功率0-7（分布范围内从0到8 kHz） lspFreq 从8个LPC系数计算出的8个线谱对频率。 F0finEnv 平滑的基频轮廓线。 voicingFinalUnclipped 最终基频候选的发声概率。Unclipped的意思是，当其低于浊音阈值时，它不被设置为零。 附加到低级描述符名称的后缀_sma表示它们是通过窗口长度为3的移动平均滤波器进行平滑。附加到sma的后缀_de表示当前特征是低级描述符平滑后的一阶delta系数（微分）。出现在Arff文件中的21个函数的名字,均在以下列表中： maxPos 最大值的绝对位置（以帧为单位） minPos 最小值的绝对位置（以帧为单位） amean 轮廓的算术平均值 linregc1 轮廓线性逼近的斜率（m） linregc2 轮廓线性逼近的偏移量（t） linregerrA 把线性误差计算作为线性近似值和实际的轮廓的误差 linregerrQ 把二次误差计算作为线性近似值和实际的轮廓的误差 stddev 轮廓中的值的标准偏差 skewness 偏度（3阶矩）。 kurtosis 峰度（4阶矩）。 quartile1 第一四分位数（25％百分位数） quartile2 第一四分位数（50％百分位数） quartile3 第一四分位数（75％百分位数） iqr1-2 四分位数间距：quartile2- quartile1 iqr2-3 四分位数间距：quartile3- quartile2 iqr1-3 四分位数间距：quartile3- quartile1 percentile1.0 轮廓的离群值鲁棒最小值，按1％百分位数表示。 percentile99.0 轮廓的离群值鲁棒最大值，按99％百分位数表示。 pctlrange0-1 由1％和99％的百分点的范围表示的离群值鲁棒信号范围“max-min”。 upleveltime75 信号超过（75％*范围+min）的时间百分比。 upleveltime90 信号超过（90％*范围+min）的时间百分比。 四个音高相关的LLD（及相应的delta系数）如下（清音区域均为0，因此功能仅适用于这些轮廓的浊音区域）： F0final 平滑的基频频率 jitterLocal 本地（帧到帧）抖动（音调周期长度偏差） jitterDDP 差分帧间抖动（‘Jitter of the Jitter’） shimmerLocal 本地（帧到帧）闪烁（音调周期幅度偏差） 对这4 + 4个LLD应用了19个函数，即上述21个函数的集合没有最小值（1％百分位数）和范围。 The INTERSPEECH 2011 Speaker State Challenge feature set（见2011年INTERSPEECH会议论文集）由配置文件config/IS11_speake_state.conf提供。该集包含的4368个特征是由4个能量相关+50个频谱相关的低级描述符（LLDs）和54个相应的delta作为108个LLDs，在此基础上应用33个基本函数+平均值、最小值、最大值、标准差得到3996个特征；5个声音相关和5个对应的delta作为10个LLDs，在此基础上应用33个基本函数+二次平均、上升时长、下降时长得到360个特征；6个F0基本函数和对应的delta，12个特征。 The INTERSPEECH 2012 Speaker Trait Challenge feature set（见2012年INTERSPEECH会议论文集）由配置文件config/IS12_speake_trait.conf提供。该集包含的6125个特征。 The INTERSPEECH 2013 ComParE Challenge feature set （见2013年INTERSPEECH会议论文集）由配置文件config/IS13_ComParE.conf提供。该集包含的6373个特征，LLD包括能量，频谱，倒谱（MFCC）、声音、对数谐波噪声比（HNR），频谱谐度和心理声学频谱清晰度。 The MediaEval 2012 TUM feature set for violent video scenes detection 针对好莱坞流行电影的暴力进行检测的特征集在config/mediaeval2012_tum_affect/，里面有不同的设置，参考文章：Florian Eyben, Felix Weninger, Nicolas Lehment, Gerhard Rigoll, Björn Schuller: ”Violent Scenes Detection with Large, Brute-forced Acoustic and Visual Feature Sets”, Proc. MediaEval 2012 Workshop, Pisa, Italy, 04.-05.10.2012. MediaEval Audio IS12based subwin2.conf包含的是从2s的子窗中提取音频特征的配置。MediaEval Audio IS12based subwin2 step0.5.conf提取一样的特征，但是2s子窗的偏移为0.5s。MediaEval VideoFunctionals.conf用于视频特征提取，如文章使用方法，需要一个包含LLDs的CSV文件（由openCV提取）作为输入和输出，ARFF文件作为视频特征。 The openSMILE/openEAR ‘emobase’ set早期的基线集（参照”emobase2”集作为新的基线集），拥有情感识别的998个声学特征，包含以下低级描述符（LLDs）：强度，响度，12 MFCC，音高（F0），浊音概率，F0包络线，8 LSF（线频谱频率），过零率， 以及这些LLD的Delta回归系数。以下函数被应用于上述LLDs及其Delta系数。：Max./Min。输入的相对位置和范围，范围，算术平均值，2线性回归系数，线性和二次误差，标准差，偏度，峰度，四分位数1-3和三位四分位数范围。 The large openSMILE emotion feature set用于提取更多的LLDs和更多的函数(6552个特征)，配置文件为config/emo_large.conf。 The openSMILE ‘emobase2010’ reference set 是基于the INTERSPEECH 2010 Paralinguistic Challenge feature set，配置文件为config/emobase2010.conf。对持续时间和位置特征的规范化进行了一些调整。这个特性集包含了一套大大增强的低级描述符(LLDs)，以及一套“emobase”相比更加精细化选择的函数列表。建议使用此特征集作为比较新的情感识别特征集和方法的参考，因为它代表当前最先进的情感和语言识别功能。该集合包含1582个特征（与INTERSPEECH 2010 Paralinguistic 挑战集相同设置），其由34个低级描述符（LLDs）和34个相应的delta作为68个LLDs轮廓值，在此基础上应用21个函数得到1 428个特征，另外，对4个基于音高的LLD及其4个delta系数应用了19个函数得到152个特征，最后附加音高（伪音节）的数量和总数输入的持续时间（2个特征）。唯一的区别是INTERSPEECH 2010 paralinguistic挑战集标准化的是是“maxPos”和“minPos”特征，本配置被标准化为段长度。 python批处理提取openSMILE特征所有支持标准数据输出格式的配置文件都可以在WINDOWS的批特征提取GUI（使用VS10 C#编写，位于progsrc/openSMILEbatchGUI/）。这个工具允许openSMILE自动的执行文件夹中的若干文件。它可以在图形界面中选择音频文件和指定输出类型。openSMILE本身提供批处理GUI（使用VS10 C#编写，位于progsrc/openSMILEbatchGUI/），但若语音数据的目录结构较复杂，还可以利用python来进行批处理。示例代码如以下： import os from subprocess import call def excute_CMD(path_ExcuteFile, path_Config, path_Audio, path_Output): cmd = path_ExcuteFile + &quot; -C &quot; + path_Config + &quot; -I &quot; + path_Audio + &quot; -O &quot; + path_Output call(cmd, shell=True) def batch_extract_features(path_Config, path_Input_Root, path_Output): path_ExcuteFile = &quot;SMILExtract_Release&quot; filename = os.listdir(path_Input_Root) for i in range(len(filename)): print(&#39;Extracting features of %s&#39; % filename[i]) path_Input = path_Input_Root + &#39;/&#39; + filename[i] + &#39;.wav&#39; excute_CMD(path_ExcuteFile, path_Config, path_Input, path_Output) path_Config = &quot;./config/IS13_ComParE.conf&quot; path_Input_Root = &#39;root_path_to_audio/&#39; path_Output = &#39;features.csv&#39; batch_extract_features(path_Config, path_Input_Root, path_Output) 输出数据格式控制对于不包含统计函数的配置文件，选项定义在config/shared/standard_data_output_lldonly.conf.inc ==============================LLD only============================= ================================CSV================================ -csvoutput &lt;filename&gt; 默认输出选项. CSV格式，存放帧向LLD -appendcsv &lt;0/1&gt; 设为1代表添加到已有CSV文件文末，默认0 -timestampcsv &lt;0/1&gt; 设为0禁止把时间步输出到CSV第二列，默认为1 -headercsv &lt;0/1&gt; 设为0禁止把标题输入到CSV，默认为1 ================================HTK================================ -output &lt;filename&gt; 输出特征汇总（函数）到HTK格式文件 ================================ARFF=============================== -arffoutput &lt;filename&gt; 默认输出选项. ARFF格式，存放帧向LLD -appendarff &lt;0/1&gt; 设为0代表不添加到已有ARFF文件文末，默认1添加 -timestamparff &lt;0/1&gt; 设为0禁止把时间步输出到ARFF第二列，默认为1 arfftargetsfile &lt;file&gt;指定配置包含定义目标域（类）的文，默认为:shared/arff_targets_conf.inc 对于包含统计函数的配置文件，如全部的INTERSPEECH和AVEC挑战集，选项定义在config/shared/standard_data_output.conf.inc =============================LLD and func ========================= -instname &lt;string&gt; 通常是输入文件的名称保存在CSV和ARFF输出的首列。默认是&quot;unknow&quot; ================================ARFF=============================== -lldarffoutput, -D &lt;filename&gt; 启动LLD帧向输出到ARFF格式文件 -appendarfflld &lt;0/1&gt; 设为1代表添加到已有ARFF文件文末，默认0覆盖 -timestamparfflld &lt;0/1&gt; 设为0禁止把时间步输出到ARFF第二列，默认为1 -lldarfftargetsfile &lt;file&gt; 指定配置包含定义目标域（类）的文，默认为: shared/arff_targets_conf.inc ================================CSV================================ -lldcsvoutput, -D &lt;filename&gt; 启动LLD帧向输出到CSV格式文件 -appendcsvlld &lt;0/1&gt; 设为1代表添加到已有CSV文件文末，默认0覆盖 -timestampcsvlld &lt;0/1&gt; 设为0禁止把时间步输出到CSV第二列，默认为1 -headercsvlld &lt;0/1&gt; 设为0禁止把标题输入到CSV，默认为1 ================================HTK================================ -lldhtkoutput &lt;filename&gt; 启动LLD帧向输出到HTK格式文件 ================================ARFF=============================== -output, -O &lt;filename&gt; 默认输出选项. ARFF格式，存放特征汇总 -appendarff &lt;0/1&gt; 设为0代表不添加到已有ARFF文件文末，默认1添加 -timestamparff &lt;0/1&gt; 设为1把时间步输出到ARFF第二列，默认为0 -arfftargetsfile &lt;file&gt;指定配置包含定义目标域（类）的文，默认为: shared/arff_targets_conf.inc ================================CSV================================ -csvoutput &lt;filename&gt; 默认输出选项. CSV格式，存放特征汇总 -appendcsv &lt;0/1&gt; 设为0代表不添加到已有CSV文件文末，默认1 -timestampcsv &lt;0/1&gt; 设为0禁止把时间步输出到CSV第二列，默认为1 -headercsv &lt;0/1&gt; 设为0禁止把标题输入到CSV，默认为1 ================================HTK================================ -htkoutput &lt;filename&gt; 输出特征汇总（函数）到HTK格式文件 如下为lldcsvoutput的定义。注：从2.2版本起，可以指定一个“?”替代文件名。它会禁止相应的输出组件，即它不会产生输出文件，在标准输出接口界面，看到的所有的文件名默认都是”?” [lldsink:cCsvSink] reader.dmLevel = lld;lld_de filename=\\cm[lldcsvoutput(D){?}:output csv file for LLD, disabled by default ?, only written if filename given] instanceName=\\cm[instname(N){unknown}:instance name] append = \\cm[appendcsvlld{0}:set to 1 to append to the LLD output csv file, default is not to append] timestamp = \\cm[timestampcsvlld{1}:set to 0 to suppress timestamp column, default is 1, i.e. to show timestamp in second column] number = 0 printHeader = \\cm[headercsvlld{1}:set to 0 to suppress header line with feature names, default is 1, i.e. to show header line] errorOnNoOutput = 1 那么，当需要同时输出lld和func时，可用如下命令 SMILExtract -C config/IS13_ComParE.conf -I input.wav -lldcsvoutput lld_output.csv -csvoutput func_output.csv 最后一点话其实如果只是用官方配置提特征那么只看批处理那里也够了。官方配置文件可以根据需求时再看需要哪个文件，也可自己按着这个格式自定义编写配置文件。另外输出格式控制感觉最好也是先看一下，我一开始都是直接用 -O 输出统计特征，但想输出lld时跑去源代码里一阵捣鼓，后来才发现它已经封装好了直接一个参数就可以了。 彩蛋","categories":[{"name":"语音特征","slug":"语音特征","permalink":"http://weiquanfan.xyz/categories/语音特征/"}],"tags":[]},{"title":"语谱图的matlab提取和python提取","slug":"specgram","date":"2020-05-02T08:43:28.000Z","updated":"2020-05-27T10:45:09.634Z","comments":true,"path":"2020/05/02/specgram/","link":"","permalink":"http://weiquanfan.xyz/2020/05/02/specgram/","excerpt":"","text":"前言语谱图（spectrogram或specgram），也叫声谱图，可以简单看做一个二维矩阵，其纵轴表示频率，横轴表示时间，矩阵的值表示能量强弱。由于它拥有着频率和时间两个维度的信息，所以是比较综合地表示原语音信息的一种特征。另外，我将其看做语音和图像的一种连接，因为图像领域的模型发展得较快，所以通过这种方式把语音转换成一种特殊的图像再进一步处理。 语谱图流程简介1. 将语音可交叉地分成多帧（由于语音的短时平稳性） 2. 各帧加窗 3. 各帧通过快速傅里叶变化（fft）得到频谱向量 4. 沿着时间轴并联各频谱向量得到语谱图 语谱图的提取语谱图的matlab提取先看一段非官方代码，结合上述步骤进行理解。 [x,Fs,nBits]=wavread(&#39;audio.wav&#39;); s=length(x); % 信号长度 w=256; % 窗长 n=w; % nfft，表示做fft变换需要的点数，一般为刚大于w的2的幂。举例，w=250，则n一般设为256 ov=w/2; % 分帧的交叉程度，常见设为窗长的二分之一或四分之一 h=w-ov; % 不重叠点数 win=hamming(n)&#39;;% 选了常见的汉明窗，并设置nfft c=1; % 指向当前帧的指针 ncols=1+fix((s-n)/h); % 计算总共有多少帧 d=zeros((1+n/2),ncols); % 语谱图初始化 for b=0:h:(s-n) % 以下处理各帧 u=win.*x((b+1):(b+n)); % 各帧加窗 t=fft(u,n); % 各帧进行fft，内容为u，nfft=n。对于fft，输入n个时域点，输出n个频域点 d(:,c)=t(1:(1+n/2))&#39;; % 并联频谱向量，注意只取1+n/2，因为负频率无意义，只留下0和正频率 c=c+1; % 移动指针 end tt=[0:h:(s-n)]/Fs; % 时间轴 ff=[0:(n/2)]*Fs/n; % 频率轴 imagesc(tt/1000,ff/1000,20*log10(abs(d))); % 绘制 colormap(hot); axis xy xlabel(&#39;时间/s&#39;); ylabel(&#39;频率/kHz&#39;); 然而，matlab其实有封装好的函数可以直接调用。 [S,F,T]=specgram(x,nfft,Fs,windows_length,overlap_length) % x 为整段语音 % nfft 为fft变换点数，其实可以直接用默认的刚大于窗长的2的幂。也可自定义为大于窗长的整数，会对帧进行补零操作 % Fs 语音采样频率 % windows_length 窗长 % overlap_length 交叉长度 % S 语谱图 % F 频率值，尺度为1+n/2 % T 时间值，尺度为1+fix((s-n)/h) 语谱图的python提取有了刚才的基础，python的代码就容易理解啦。首先同样看一下不直接调用函数的写法。 import numpy as np from scipy.io import wavfile import matplotlib.pyplot as plt Fs, x = wavfile.read(&#39;audio.wav&#39;) wave = np.array(x[:,0], dtype = &quot;float&quot;) frame_len = 1000 frame_off = frame_len // 2 # 非重叠点数 specg_len = 1024 # 可以想象1是代表第一帧，然后第二帧结尾超出第一帧frame_off个点，第三帧再超出第二帧frame_off个点，总共第二帧到最后一帧共有(wave.size - frame_len) // frame_off 帧 frame_num = (wave.size - frame_len) // frame_off + 1 # 生成汉明窗 hamwindow = np.hamming(frame_len) specg = np.zeros((frame_num, specg_len // 2 + 1)) z = np.zeros(specg_len - frame_len) for idx in range(frame_num): base = idx * frame_off frame = wave[base: base + frame_len] # 分帧 frame = np.append(frame * hamwindow, z) # 加窗 specg[idx:] = np.log10(np.abs(np.fft.rfft(frame))) # FFT，返回幅度谱 specg = np.transpose(specg) io.savemat(&#39;specgram.mat&#39;, {&#39;specg&#39;:specg}) # aspect设为auto即可自动拉宽图 plt.imshow(specg, origin=&quot;lower&quot;, cmap = &quot;jet&quot;, aspect = &quot;auto&quot;, interpolation = &quot;none&quot;) plt.show() plt.xticks([]) plt.yticks([]) plt.savefig(‘specgram.png&#39;,bbox_inches=&#39;tight&#39;,pad_inches=0.0) plt.close() 再看看已经封装好的版本。 from scipy import io from scipy.io import wavfile import matplotlib.pyplot as plt Fs, x = wavfile.read(&#39;audio.wav&#39;) # 读取音频 specg = plt.specgram(x, Fs = Fs, pad_to = 256, NFFT = 256, noverlap = 128) # 提取语谱图，一键操作！ io.savemat(&#39;specgram.mat&#39;, {&#39;specg&#39;:specg[0]}) # 保存语谱图 ## 照例解释下参数 # x，Fs和上边一样 # pad_to为上边的nfft # NFFT为上边的windows_length（为什么nfft不设置为上边的nfft呢，迷惑） # noverlap为上边的overlap_length 语谱图的一些可能有的小疑惑 关于nfftnfft既表示时域的点数也关联频域的点数。该数为2的幂数时更高效，但不是也没问题。nfft需要比窗长的值更大，然后加窗后的帧会被补零到nfft长度再进行fft。 关于频率分辨率频率轴上每一个点对应fs/nfft的频率。另外由于输出nfft/2+1个频率点，所以输出的频率范围为0到nfft/2×fs/nfft=fs/2。 关于自定义输出语谱图的尺寸问题时间轴尺寸为1+fix((s-n)/h)， 由windows_length和overlap_length决定。实际应用时由于各语音长度不同，时间尺寸一般都要进行截断或补零到一个固定值。截断的话可以截一段（起始信息，中间信息），也可以截多段（交叉不交叉都行）。频率轴尺寸为1+n/2，仅决定于nfft（python中的pad_to参数），所以可以通过设置该值控制频率轴尺寸。但是也不要比窗长大太多，否则补零太多可能就没什么信息了。nfft调大时，窗长可以跟着调大，为了防止导致的时间轴太短可以调高overlap_length。另外，其他参数不变时，仅变换nfft，可视化出来时可能肉眼看起来一样，但实际分辨率仍然是不同的。这也导致了一个问题，送入网络的是要用单通道的直接计算出来的语谱图，还是用可视化函数绘制出来的三通道的语谱图，这就根据实际情况去尝试了。 彩蛋 希望疫情早点过去","categories":[{"name":"语音特征","slug":"语音特征","permalink":"http://weiquanfan.xyz/categories/语音特征/"}],"tags":[]},{"title":"使用Github Pages和Hexo搭建自己的独立博客","slug":"How-to-use-Hexo-to-build-your-blog","date":"2019-08-11T11:10:47.000Z","updated":"2019-08-14T17:28:12.904Z","comments":true,"path":"2019/08/11/How-to-use-Hexo-to-build-your-blog/","link":"","permalink":"http://weiquanfan.xyz/2019/08/11/How-to-use-Hexo-to-build-your-blog/","excerpt":"","text":"前言 Github Pages: Github Pages可以被认为是用户编写的、托管在github上的静态网页。 Hexo: Hexo是一个快速、简洁且高效的博客框架。 安装Node.js点击此处访问官网，按需下载相应版本，默认安装可以了。 安装Hexo$ sudo npm install -g hexo-cli 若报错，尝试： $ sudo npm install --unsafe-perm --verbose -g hexo 初始化，建立博客项目选定博客网站项目程序文件的存放位置，如/Users/tobefans/Documents/Blog/，Bash中cd进入该目录下，执行命令： $ hexo init 执行完毕后，该命令将在当前目录下生成一套标准的Hexo博客项目模板 命令$ hexo g 生成静态网站文件 $ hexo s 启动本地服务器 $ hexo d 发布博客到GitHub 发布博客创建github.io仓库在自己的GitHub中，创建新仓库，标准命名为GitHub用户名.github.io，例如我的：tobefans.github.io 配置SSH密钥只有配置好 SSH 密钥后，我们才可以通过 git 操作实现本地代码库与 Github 代码库同步，在你第一次新建的文件夹里输入以下命令： $ ssh-keygen -t rsa -C &quot;your email@example.com&quot; //引号里面填写你的邮箱地址，比如我的是weiquan.fan96@gmail.com 之后复制~/.ssh/id_rsa.pub的公钥，在Github账号中添加进该公钥。 Git 会根据用户的名字和邮箱来记录提交，GitHub 也是用这些信息来做权限的处理，输入以下命令进行个人信息的设置，把名称和邮箱替换成你自己的，名字可以不是 GitHub 的昵称，但为了方便记忆，建议与 GitHub 一致。 $ git config --global user.name &quot;此处填你的用户名&quot; $ git config --global user.email &quot;此处填你的邮箱&quot; 可通过ssh -T git@github.com测试是否添加成功。 将本地的 Hexo 文件更新到 Github 的库中打开创建的 Hexo 文件夹下的 _config.yml，修改如下的代码段，repo为github项目的地址。 deploy: type: git repo: git@github.com:tobefans/tobefans.github.io.git branch: master 如果此时报以下错误，说明你的 deployer 没有安装成功 ERROR Deployer not found: git 需要执行以下命令再安装一次： $ npm install hexo-deployer-git --save 再执行 hexo g -d，你的博客就会部署到 Github 上了 访问博客在github该项目的setting中打开Github pages的设置。 你的博客地址：https://你的用户名.http://github.io，比如我的是：https://tobefans.github.io ，现在每个人都可以通过此链接访问你的博客了。 为博客更换自己喜欢的主题点击此处进入 Hexo 官网的主题专栏，我们可以看见有许多的主题供我们选择。我们要做的就是把主题克隆过来，在此我们以主题 Aero-Dual 为例，点进去我们就可以看见该主题作者的博客，鼠标滑到底，我们可以看见 Theme By Levblanc 的字样（其他主题类似），点击作者 Levblanc ，页面就会跳转到该主题所有的相关文件在 Github 上的地址，下载该项目，放至Hexo文件夹中的themes目录。 然后打开 Hexo 文件夹下的配置文件 _config.yml ，找到关键字 theme，修改参数为：theme：hexo-theme-aero-dual （其他主题修改成相应名称即可），再次注意冒号后面有一个空格。再通过$ hexo g更新。 另推荐一款主题：Next 在Hexo中渲染MathJax数学公式更换Hexo的markdown渲染引擎，hexo-renderer-kramed引擎是在默认的渲染引擎hexo-renderer-marked的基础上修改了一些bug，两者比较接近，也比较轻量级。在Hexo文件夹位置命令： npm uninstall hexo-renderer-marked --save npm install hexo-renderer-kramed --save 接下来到博客根目录下，找到node_modules\\kramed\\lib\\rules\\inline.js，把第11行的escape变量的值做相应的修改，这一步是在原基础上取消了对\\,{,}的转义(escape)。同时把第20行的em变量也要做相应的修改。 // escape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_&gt;])/, escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/ // em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/ 进入到主题目录，找到_config.yml配置问题，把mathjax默认的false修改为true，具体如下： # MathJax Support mathjax: enable: true per_page: true 在文章的Front-matter里打开mathjax开关，如下： --- title: 使用Github Pages和Hexo搭建自己的独立博客 date: 2019-08-11 19:10:47 tags: mathjax: true --- 这里有常见数学公式。 绑定域名通过阿里云之类的获得域名后，先解析域名如下。 记录类型 主机记录 记录值 CNAME www 你的github用户名.github.io A @ 192.30.252.153 A @ 192.30.252.154 在Hexo文件夹的source文件夹中，创建一个CNAME文件，存储预备使用的个人域名，如：weiquanfan.xyz也可通过github项目上setting里映射个人域名。 清理Hexo缓存并更新Hexo静态网站 $ hexo clean &amp;&amp; hexo g $ hexo clean $ hexo g -d Valine——评论系统Valine 诞生于 2017 年 8 月 7 日，是一款基于 Leancloud 的快速、简洁且高效的无后端评论系统。 注册帐号创建应用:请先登录或注册 LeanCloud, 进入控制台后点击左下角创建应用，选用免费的开发版应用即可。 应用设置:进入应用。在 设置 -&gt; 安全中心 ，把文件上传、短信服务、推送服务、实时通信这几个服务全部关闭，因为用不到。在 Web 安全域名 里填入想要打开评论系统的域名，如weiquanfan.xyz在 设置 -&gt; 应用 Key 找到APP ID和APP Key。 配置 Hexo 参数:打开 Hexo 主题的配置文件_config.yml，搜索一下 Valine，打开enable，并填写APP ID 和 APP Key。 更新网站:运行hexo g -d推送到博客。 此外，还需要注意，如果博客还有除正文内容之外的页面存在，例如关于、分类、标签，要把他们的 Markdown 文件的 comments 属性设置为 false，否则这些页面在展示的时候也会有评论的功能出现。 --- title: 使用Github Pages和Hexo搭建自己的独立博客 date: 2019-08-11 19:10:47 tags: mathjax: true comments: false --- 统计阅读量阅读量分两种：不蒜子统计站点的总访问量，即统计浏览了多少次；有多少人访问，在footer显示。LeanCloud统计单篇博文的阅读量，即统计单篇博文的阅读量是多少。 单篇博文的阅读量通过Valine实现，其实和评论系统差不多。在 存储 中新建Class，Class名称必须为Counter。并相应更改主题配置文件的leancloud_visitors，打开enable，并填写APP ID 和 APP Key。 站点的总访问量通过不蒜子实现。找到站点的themes/next/layout/_partials/footer.swig文件。插入代码如下。 {% if theme.footer.theme.enable %} {# #}{{ __('footer.theme') }} &mdash; {# #}{# #}NexT.{{ theme.scheme }}{# #}{% if theme.footer.theme.version %} v{{ theme.version }}{% endif %}&lt;/div&gt; # 此位置插入以下代码 &lt;div&gt; &lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 本站总访问量 &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; 次&amp;nbsp&amp;nbsp&amp;nbsp 本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次 &lt;/div&gt; {% endif %} 彩蛋 喜大普奔，完成啦！！","categories":[],"tags":[]}],"categories":[{"name":"界面","slug":"界面","permalink":"http://weiquanfan.xyz/categories/界面/"},{"name":"强化学习","slug":"强化学习","permalink":"http://weiquanfan.xyz/categories/强化学习/"},{"name":"爬虫","slug":"爬虫","permalink":"http://weiquanfan.xyz/categories/爬虫/"},{"name":"深度学习模型","slug":"深度学习模型","permalink":"http://weiquanfan.xyz/categories/深度学习模型/"},{"name":"机器学习","slug":"机器学习","permalink":"http://weiquanfan.xyz/categories/机器学习/"},{"name":"语音特征","slug":"语音特征","permalink":"http://weiquanfan.xyz/categories/语音特征/"}],"tags":[{"name":"界面","slug":"界面","permalink":"http://weiquanfan.xyz/tags/界面/"},{"name":"强化学习","slug":"强化学习","permalink":"http://weiquanfan.xyz/tags/强化学习/"},{"name":"attention","slug":"attention","permalink":"http://weiquanfan.xyz/tags/attention/"},{"name":"BERT","slug":"BERT","permalink":"http://weiquanfan.xyz/tags/BERT/"},{"name":"Transformer","slug":"Transformer","permalink":"http://weiquanfan.xyz/tags/Transformer/"},{"name":"GLUE","slug":"GLUE","permalink":"http://weiquanfan.xyz/tags/GLUE/"}]}